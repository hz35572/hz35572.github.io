<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2022/08/10/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2022/08/10/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>智能指针是C++11引入的新特性,用于解决以下问题:</p><ul><li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li><li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li><li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li></ul><p>使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。</p><p>C++中的智能指针有4种，分别为：<strong>shared_ptr</strong>、<strong>unique_ptr</strong>、<strong>weak_ptr</strong>、<strong>auto_ptr</strong>，其中auto_ptr被C++11弃用。</p><h1 id="三种智能指针的区别"><a href="#三种智能指针的区别" class="headerlink" title="三种智能指针的区别"></a>三种智能指针的区别</h1><p><strong>shared_ptr和unique_ptr都支持的操作</strong><br><img data-src="https://img-blog.csdnimg.cn/f2b3eb13527b456da3aaa7f7d6cc5768.png" alt="在这里插入图片描述"></p><h2 id="unique-ptr指针"><a href="#unique-ptr指针" class="headerlink" title="unique_ptr指针"></a>unique_ptr指针</h2><ul><li><p><strong>unique_ptr原理:</strong><br> unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。</p></li><li><p><strong>unique_ptr操作:</strong><br><img data-src="https://img-blog.csdnimg.cn/4e0a60e7904a40e58405e72bcb1ebc79.png" alt="在这里插入图片描述"><br><strong>以下为unique_ptr的基本使用示例</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; <span class="comment">// 测试unique_ptr自动释放内存资源</span></span><br><span class="line">    <span class="function">unique_ptr&lt;C&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> C())</span></span>;</span><br><span class="line">    C* p2 = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">// 普通指针没有delete不能自动释放内存资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;this is pu1&quot;</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;string&gt; pu2 = <span class="built_in">move</span>(pu1); <span class="comment">//不能直接将unique_ptr赋值,必须要用move()转化为临时对象</span></span><br><span class="line">    unique_ptr&lt;string&gt; pu3;</span><br><span class="line">    pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;this is pu3&quot;</span>));</span><br><span class="line">    cout &lt;&lt; *pu2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用release释放当前unique_ptr指针对所指堆内存的所有权,并且返回一个指向该堆内存指针用reset将该指针赋给pu1</span></span><br><span class="line">    pu1.<span class="built_in">reset</span>(pu3.<span class="built_in">release</span>()); </span><br><span class="line">    cout &lt;&lt; *pu1 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">this is pu1</span></span><br><span class="line"><span class="comment">this is pu3</span></span><br><span class="line"><span class="comment">C constructor</span></span><br><span class="line"><span class="comment">C constructor</span></span><br><span class="line"><span class="comment">C delete</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><p><strong>为 unique_ptr 自定义释放规则</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myDel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;myDel\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为 unique_ptr 自定义释放规则</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>[], myDel&gt; <span class="title">p_arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>; <span class="comment">//使用可调用的类</span></span><br><span class="line">    <span class="keyword">auto</span> myDel2 = [](<span class="type">int</span>* p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;myDel2\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>[], <span class="title">decltype</span><span class="params">(myDel2)</span>&gt; <span class="title">p_arr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>], myDel2)</span></span>; <span class="comment">//使用lambda函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">myDel2</span></span><br><span class="line"><span class="comment">myDel</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="shared-ptr指针"><a href="#shared-ptr指针" class="headerlink" title="shared_ptr指针"></a>shared_ptr指针</h2><ul><li><strong>shared_ptr的原理</strong><br>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</li><li><strong>shared_ptr的操作</strong></li></ul><p><img data-src="https://img-blog.csdnimg.cn/052ffac4b8c34b87afd2efedc31e5f51.png" alt="在这里插入图片描述"><br><strong>以下为shared_ptr使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> pc3 = <span class="built_in">make_shared</span>&lt;C&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;C&gt; pc1 = pc3; <span class="comment">//由于增加了一个新的指针使用pc3所指的内存资源,所以引用计数增加1</span></span><br><span class="line">        shared_ptr&lt;B&gt; pc2 = <span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        cout &lt;&lt; pc3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; pc2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于pc1离开其作用域后放弃对内存的“使用权”，引用计数减1</span></span><br><span class="line">    cout &lt;&lt; pc3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序输出:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">B delete</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">C delete</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="weak-ptr指针"><a href="#weak-ptr指针" class="headerlink" title="weak_ptr指针"></a>weak_ptr指针</h2><ul><li><p><strong>weak_ptr指针的原理</strong><br>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, <strong>它的构造和析构不会引起引用记数的增加或减少</strong>。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p></li><li><p><strong>weak_ptr的操作</strong><br><img data-src="https://img-blog.csdnimg.cn/f949f74e379740b494b58c04770be85a.png" alt="在这里插入图片描述"><br><strong>weak_ptr避免引用时死锁的示例</strong></p></li></ul><p>(1).shared_ptr相互引用时造成死锁的示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_; <span class="comment">// weak_ptr指针的构造和析构不会引起引用计数的增加和减少</span></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am A!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">   </span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pa和pb的引用计数为2,离开此作用域后减为1,所以内存不会被释放</span></span><br><span class="line">    cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2).将类中的指针类型改为weak_ptr后:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;B&gt; pb_; <span class="comment">// weak_ptr指针的构造和析构不会引起引用计数的增加和减少</span></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am A!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">   </span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">A delete</span></span><br><span class="line"><span class="comment">B delete</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb-&gt;print(); 英文pb是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p &#x3D; pa-&gt;pb_.lock(); p-&gt;print(); </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pb-&gt;pa_-&gt;print(); 错误</span></span><br><span class="line">shared_ptr p = pb-&gt;pa_.<span class="built_in">lock</span>();</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++static关键字</title>
    <link href="/2022/07/23/Cpp-static/"/>
    <url>/2022/07/23/Cpp-static/</url>
    
    <content type="html"><![CDATA[<p>static关键字使用时具有以下含义：</p><ul><li><strong>静态变量</strong>: 函数中的变量，类中的变量</li><li><strong>静态类成员</strong>: 类对象和类中的函数</li></ul><h1 id="一、静态变量"><a href="#一、静态变量" class="headerlink" title="一、静态变量"></a>一、静态变量</h1><ol><li>函数中的静态变量</li></ol><p>当变量声明为static时，空间将在程序的生命周期内分配。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。这对于在C &#x2F; C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><p>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>在上面的程序中变量count被声明为static。因此，它的值通过函数调用来传递。每次调用函数时，都不会对变量计数进行初始化。</p><ol start="2"><li>类中的静态成员</li></ol><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>.对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始,只能使用类外的类名和范围解析运算符显式初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Apple</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Apple::i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Apple obj1;</span><br><span class="line">    cout &lt;&lt; obj1.i &lt;&lt; endl; <span class="comment">//输出2</span></span><br><span class="line">    Apple obj2;</span><br><span class="line">    <span class="comment">// obj1.i = 2; 错误</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; obj2.i; <span class="comment">// 输出3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、静态成员"><a href="#二、静态成员" class="headerlink" title="二、静态成员"></a>二、静态成员</h1><ol><li>类对象为静态</li></ol><p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p><p>考虑以下程序，其中对象是非静态的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Apple</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Apple</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        Apple obj1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">Constructor</span></span><br><span class="line"><span class="comment">Destructor</span></span><br><span class="line"><span class="comment">End of main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在上面的程序中，对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内。 如果我们将对象声明为静态，现在让我们看看输出的变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Apple</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Apple</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">static</span> Apple obj1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">Constructor</span></span><br><span class="line"><span class="comment">End of main</span></span><br><span class="line"><span class="comment">Destructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。</p><ol start="2"><li>类中的静态函数</li></ol><p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Apple</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++; <span class="comment">// 正确</span></span><br><span class="line">        <span class="comment">// b++; 错误，b为非静态成员变量</span></span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Apple</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Apple::a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Apple::<span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出: 101</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++const关键字</title>
    <link href="/2022/07/20/Cpp-const%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/07/20/Cpp-const%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="一、const的含义"><a href="#一、const的含义" class="headerlink" title="一、const的含义"></a>一、const的含义</h1><p>C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。</p><h1 id="二、const的作用"><a href="#二、const的作用" class="headerlink" title="二、const的作用"></a>二、const的作用</h1><ul><li>可用于代替 #define 定义常量，可以进行类型检查，并且节省空间，避免不必要的内存分配</li></ul><blockquote><p>const常量和 #define 宏定义常量的区别:</p><ul><li><p>编译器处理方式不同.define宏是在预处理阶段展开,const常量是编译运行阶段使用</p></li><li><p>类型和安全检查不同.define宏没有类型，不做任何类型检查，仅仅是展开,const常量有具体的类型，在编译阶段会执行类型检查</p></li><li><p>存储方式不同.define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配</p></li><li><p>const定义的常量在程序运行过程中只有一份拷贝,而 #define 定义的常量在内存中有若干个拷贝。因此const可以节省空间</p></li></ul></blockquote><ul><li>防止修改，起保护作用，增加程序健壮性.如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    i++; <span class="comment">//错误,const常量不可修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、const对象默认为文件局部变量"><a href="#三、const对象默认为文件局部变量" class="headerlink" title="三、const对象默认为文件局部变量"></a>三、const对象默认为文件局部变量</h1><p>非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。(extern变量可以在其他文件被访问)</p><blockquote><p>如,未被未被const修饰的变量在不同文件的访问</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在extern_file1.cpp文件中访问file1文件中的变量i</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern_file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//在访问的变量前加上extern关键字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl; <span class="comment">//输出10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>被const修饰的变量在不同文件中的访问</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>; <span class="comment">//如果要在其他文件中被访问,必须要加上extern</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在extern_file1.cpp文件中访问file1文件中的变量i</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern_file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i; <span class="comment">//在访问的变量前加上extern关键字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl; <span class="comment">//输出10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、指针与const"><a href="#四、指针与const" class="headerlink" title="四、指针与const"></a>四、指针与const</h1><ol><li><p>指向常量的指针<br>指针所指对象的值不能被修改,但指针可以被修改,并且非const对象的地址可以赋给指向常量的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="comment">//*p = 10; 错误</span></span><br><span class="line">p = &amp;b; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li><li><p>常指针<br>const指针必须进行初始化，且const指针的值不能修改,但const所指对象的值可以被修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;b; <span class="comment">//const在*右边</span></span><br><span class="line">*p = <span class="number">100</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">//p = &amp;c; 错误</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>指向常量的常指针</p></li></ol><p>指针的值不能被修改,且指针指向对象的值也不能被修改,且必修要进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;b;</span><br><span class="line"><span class="comment">//*p = 100;错误</span></span><br><span class="line"><span class="comment">//p = &amp;c; 错误</span></span><br></pre></td></tr></table></figure><h1 id="五、函数中使用const"><a href="#五、函数中使用const" class="headerlink" title="五、函数中使用const"></a>五、函数中使用const</h1><p>函数中使用const主要有以下两个作用</p><ol><li><p>使传入的参数指针所指内容不可变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StringCopy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><p>其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</p></li><li><p>参数为引用时,增加效率的同时防止修改</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> A &amp;a)</span></span>;</span><br></pre></td></tr></table></figure><p>将函数的参数设为引用传递,可以不需要产生临时对象,因此就没有临时对象的构造、复制、析构过程而提高效率.但是引用传递有可能改变传入的对象,因此加上const可以防止传入对象被修改.</p><p>如果是内部数据类型如void func(int x)就没有必要改写成void func(const int &amp;x),因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p><h1 id="六、类中使用const"><a href="#六、类中使用const" class="headerlink" title="六、类中使用const"></a>六、类中使用const</h1><ol><li><p>const成员变量<br>类中的const成员变量必须通过初始化列表进行初始化，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) : <span class="built_in">sum</span>(i) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>const成员函数<br>const修饰类的成员函数,不能改变对象的成员变量，也不能调用类中任何非const成员函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) : <span class="built_in">sum</span>(i) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">fun1</span>(); <span class="comment">//错误</span></span><br><span class="line">        <span class="built_in">fun2</span>(); <span class="comment">//正确</span></span><br><span class="line">        a += <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">fun2</span>();</span><br><span class="line">        a = <span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a + <span class="number">100</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>const对象</p></li></ol><p>const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.<br>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) : <span class="built_in">sum</span>(i) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> A <span class="title">obj</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">obj1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">fun</span>(); <span class="comment">//正确</span></span><br><span class="line">    obj.<span class="built_in">fun1</span>(); <span class="comment">// 错误</span></span><br><span class="line">    obj1.<span class="built_in">fun</span>(); <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>将常量变量与static结合</li></ol><p>  将const成员变量声明为static类型,可以在类外初始化</p><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> A::b = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++虚函数与纯虚函数</title>
    <link href="/2022/07/18/Cpp%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <url>/2022/07/18/Cpp%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、多态性"><a href="#一、多态性" class="headerlink" title="一、多态性"></a>一、多态性</h1><p>多态就是在同一个类或继承体系结构的基类与派生类中，用同名函数来实现各种不同的功能。</p><p><strong>静态绑定又称静态联编</strong>，是指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起。</p><p><strong>动态绑定又称动态联编</strong>，是指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数，即在程序运行时才把调用函数名与具体函数绑定在一起。</p><p><strong>编译时多态性</strong>： —静态联编(连接)—-系统在编译时就决定如何实现某一动作,即对某一消息如何处理.静态联编具有执行速度快的优点.在C++中的编译时多态性是通过函数重载和运算符重载实现的。 </p><p><strong>运行时多态性</strong>： —动态联编(连接)—-系统在运行时动态实现某一动作,即对某一消息在运行过程实现其如何响应.动态联编为系统提供了灵活和高度问题抽象的优点,在C++中的运行时多态性是通过继承和虚函数实现的。</p><h1 id="二、虚函数"><a href="#二、虚函数" class="headerlink" title="二、虚函数"></a>二、虚函数</h1><p><strong>虚函数的意义</strong></p><p>派生类对象可以赋值给基类对象， 派生类对象的地址可以赋值给指向基类对象的指针， 派生类对象可以作为基类对象的引用。</p><p>赋值相容的问题： 不论哪种赋值方式，都只能通过基类对象（或基类对象的指针或引用）访问到派生类对象从基类中继承到的成员， 不能借此访问派生类定义的成员。</p><p>虚函数使得可以通过基类对象的指针或引用访问派生类定义的成员。Virtual关键字其实质是告知编译系统，被指定为virtual的函数采用动态联编的形式编译。</p><p>如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myfun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my Base class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myfun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my Derived class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> Derived; <span class="comment">// 可以将派生类地址赋给基类指针，但不能将基类地址赋给派生类指针</span></span><br><span class="line"></span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(); <span class="comment">// 输出&quot;Derived class fun&quot;, fun为虚函数，因此调用的是派生类重新定义的fun函数</span></span><br><span class="line">    p-&gt;<span class="built_in">myfun</span>(); <span class="comment">// 输出&quot;my Base class&quot;, myfun不是虚函数,因此调用的是基类的fun函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虚函数的特征</strong>:</p><ul><li>基类指针指向派生类的对象时，通过该指针访问其虚函数将调用派生类的版本。</li><li>一旦将某个成员函数声明为虚函数后，它在继承体系中就永远为虚函数了</li><li>如果基类定义了虚函数，当通过基类指针或引用调用派生类对象时，将访问到它们实际所指对象中的虚函数版本。</li><li>只有通过基类对象的指针和引用访问派生类对象的虚函数时，才能体现虚函数的特性。</li><li>派生类中的虚函数要保持其虚特征，必须与基类虚函数的函数原型完全相同，否则就是普通的重载函数，与基类的虚函数无关。</li><li>派生类通过从基类继承的成员函数调用虚函数时，将访问到派生类中的版本。</li><li>只有类的非静态成员函数才能被定义为虚函数，类的构造函数和静态成员函数不能定义为虚函数。原因是虚函数在继承层次结构中才能够发生作用，而构造函数、静态成员是不能够被继承的。</li><li>内联函数也不能是虚函数。因为内联函数采用的是静态联编的方式，而虚函数是在程序运行时才与具体函数动态绑定的，采用的是动态联编的方式，即使虚函数在类体内被定义，C++编译器也将它视为非内联函数。</li><li>基类析构函数几乎总是为虚析构函数。 why? 假定使用delete和一个指向派生类的基类指针来销毁派生类对象，如果基类析构函数不为虚,就如一个普通成员函数，delete函数调用的就是基类析构函数。在通过基类对象的引用或指针调用派生类对象时，将致使对象析构不彻底！</li></ul><h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><p>仅定义函数原型而不定义其实现的虚函数就是纯虚函数</p><p>纯虚函数的定义方式如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>包含一个或多个纯虚函数的类就是抽象类,不能实例化抽象类,但是可以定义抽象类的指针和引用,定义一个抽象类的派生类,定义所有纯虚函数</p><p><strong>C++对抽象类具有以下限定</strong>:</p><ul><li>抽象类中含有纯虚函数，由于纯虚函数没有实现代码，所以不能建立抽象类的对象。</li><li>抽象类只能作为其他类的基类，可以通过抽象类对象的指针或引用访问到它的派生类对象，实现运行时的多态性。</li><li>如果派生类只是简单地继承了抽象类的纯虚函数，而没有重新定义基类的纯虚函数，则派生类也是一个抽象类。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++右值引用</title>
    <link href="/2022/07/17/C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2022/07/17/C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="左值和右值的区别"><a href="#左值和右值的区别" class="headerlink" title="左值和右值的区别"></a>左值和右值的区别</h1><p><strong>左值</strong>:存储在内存中、有明确存储地址（可寻址）的数据</p><p><strong>右值</strong>:没有明确存储地址（不可寻址）的值</p><p>区分左值和右值的方法:</p><ol><li><p>可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</p></li><li><p>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</p></li><li><p>返回类型为非引用的函数调用为右值</p></li><li><p>算术表达式为右值</p></li></ol><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>顾名思义,右值引用就是操纵右值的引用,如下左值引用和右值引用经典示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //错误,右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</p><p>右值引用可以对右值进行修改,例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>; <span class="comment">//c++也可以定义常右值引用,但无实际用途</span></span><br></pre></td></tr></table></figure><p><strong>右值引用的作用</strong>:如下程序,通过使用move函数将左值转化为右值,然后调用移动构造函数,直接占用临时对象的空间,可以不用开辟新的空间,起到节省空间的作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> size = <span class="number">0</span>) :<span class="built_in">size</span>(size), <span class="built_in">name</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                name[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深拷贝,将形参的所有内容复制一遍</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; stu) &#123;</span><br><span class="line">        size = stu.size;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            name[i] = stu.name[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造,直接把别人的东西占为己有</span></span><br><span class="line">    <span class="built_in">Student</span>(Student&amp;&amp; stu) &#123;</span><br><span class="line">        size = stu.size;</span><br><span class="line">        name = stu.name;</span><br><span class="line">        stu.name = <span class="literal">nullptr</span>; <span class="comment">// stu为右值,使用后即将要消亡,所以要将指针赋为空</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> name;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delect&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Student&gt; school;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 使用move将左值转化为右值,调用移动构造函数</span></span><br><span class="line">    school.<span class="built_in">push_back</span>(<span class="built_in">move</span>(stu));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF915C Permute Digits（搜索+剪枝）</title>
    <link href="/2022/07/17/CF915C/"/>
    <url>/2022/07/17/CF915C/</url>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vOTE1L0M=">题目链接</span></p><h1 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h1><p>给出两个正整数a,b。在十进制下重排a，构造一个不超过b的最大数，不能有前导零。允许不去重排a。</p><p><strong>输入格式</strong>：</p><p>第一行一个数a(1&lt;&#x3D;a&lt;&#x3D;10^18^),第二行一个数b(1&lt;&#x3D;b&lt;&#x3D;10^18^)<br>数没有前导零，数据保证有解。</p><p><strong>输出格式</strong>：</p><p>输出一个数，表示a重排后不超过b的最大数，不应该有前导零。<br>输出的数的长度应该与a相等，它应该是a的一个排列。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h1><p>以字符串的形式输入,先将a字符串从小到大排序,然后dfs搜索来找到不超过b的最大数,需要经过剪枝优化来降低复杂度</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_IT set<span class="string">&lt;node&gt;</span>::iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bug(a) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bugg(a,b) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buggg(a,b,c) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp=<span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">string s1,s2,ans;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string x,<span class="type">int</span> y,<span class="type">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">//bug(x)</span></span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">size</span>()==s1.<span class="built_in">size</span>())&#123;</span><br><span class="line">        ans=x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag&amp;&amp;s1[i]&gt;s2[y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!flag&amp;&amp;s1[i]==s2[y])&#123;</span><br><span class="line">                string st=<span class="string">&quot;&quot;</span>,st2;</span><br><span class="line">                st2=s2.<span class="built_in">substr</span>(y,s2.<span class="built_in">size</span>()-y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">                    <span class="keyword">if</span>(!vis[i])</span><br><span class="line">                        st+=s1[i];</span><br><span class="line">                <span class="built_in">sort</span>(st.<span class="built_in">begin</span>(),st.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span>(st&gt;st2) <span class="keyword">return</span> ;</span><br><span class="line">                <span class="keyword">if</span>(st==st2)&#123;</span><br><span class="line">                    ans=x+st;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s1[i]&lt;s2[y])</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x+s1[i],y+<span class="number">1</span>,flag);</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    <span class="built_in">sort</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">char</span>&gt;());</span><br><span class="line">    <span class="keyword">if</span>(s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">        ans=s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2000000000001</span></span><br><span class="line"><span class="comment">2000000000000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing4313. 满二叉树等长路径(递归+贪心）</title>
    <link href="/2022/07/17/AcWing4313/"/>
    <url>/2022/07/17/AcWing4313/</url>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDMxNi8=">题目链接</span></h1><p><strong>思路</strong><br><img data-src="https://img-blog.csdnimg.cn/d0e6b82da8424c91b9c02d74a12b2d73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASFozNTU3Mg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>若要使所有叶子节点到根节点距离相等,那么首先应使左子树的所有叶子节点到左子树根节点距离相等(设为l),使右子树所有叶子节点到右子树根节点距离相等(设为r),然后再将左右子树的所有叶子节点到根节点的距离变为 max(l,r),所以应增加的距离应为 |l-r|, 可利用递归对每一层实现这个过程</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; P;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp=<span class="number">1e-5</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=(<span class="number">1</span>&lt;&lt;n))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">dfs</span>(x*<span class="number">2</span>)+a[x*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">dfs</span>(x*<span class="number">2</span>+<span class="number">1</span>)+a[x*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    ans+=<span class="built_in">abs</span>(l-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=(<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>)<span class="number">-1</span>;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集+最小生成树（Kruskal算法）</title>
    <link href="/2022/07/16/Kruskal/"/>
    <url>/2022/07/16/Kruskal/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集常用于解决一些元素分组问题,管理一系列不相交的集合,主要操作如下:<br><strong>初始化</strong><br>将所有节点的祖先初始化为其本身:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化祖先节点,par[i]为i点的父节点,n为节点数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        par[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询</strong><br>查找祖先节点并且状态压缩,减小复杂度:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">seek</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[i]==i)<span class="comment">//若i点的父节点为它本身时,则i点为祖先节点</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> par[i]=<span class="built_in">seek</span>(par[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合并</strong><br>将两棵树合并,只需将其中一颗树的祖先节点改变为为另一棵树的祖先节点即可:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">seek</span>(x),b=<span class="built_in">seek</span>(y);</span><br><span class="line">    par[a]=b;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图两棵树合并前:<br><img data-src="https://img-blog.csdnimg.cn/20210601210027979.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjk5NDM2,size_16,color_FFFFFF,t_70#pic_center" alt="1"><br>两棵树合并后,右边的树祖先也变为了1:<br><img data-src="https://img-blog.csdnimg.cn/20210601210139367.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjk5NDM2,size_16,color_FFFFFF,t_70#pic_center" alt="2"></p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>该算法是运用并查集来求最小(或最大)生成树,主要步骤如下:<br>1.根据边权值大小将图中的每条边排序;<br>2.初始化并查集;<br>3.设图的顶点点数为n,从排序后的第一条边开始依次遍历n-1条边,将这n-1条边的权值求和,结果就为这张图的最小生成树;</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123; <span class="type">int</span> u,v,cost&#125;;<span class="comment">//边的起点、终点、权值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge&amp; e1,<span class="type">const</span> edge&amp; e2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> e1.cost&lt;e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edge es[MAXN];</span><br><span class="line"><span class="type">int</span> V,E; <span class="comment">//顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(es,es+E,cmp); <span class="comment">//按照边的权值排序</span></span><br><span class="line"><span class="built_in">init</span>(); <span class="comment">//并查集的初始化</span></span><br><span class="line"><span class="type">int</span> mst=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">seek</span>(es[i].u)!=<span class="built_in">seek</span>(es[i].v))&#123;</span><br><span class="line">            <span class="built_in">join</span>(es[i].u,es[i].v);</span><br><span class="line">            mst+=es[i].cost;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==V<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//生成树的边数最多不超过V-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路--Dijkstra算法+堆优化</title>
    <link href="/2022/07/16/Dijkstra/"/>
    <url>/2022/07/16/Dijkstra/</url>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra算法介绍"><a href="#Dijkstra算法介绍" class="headerlink" title="Dijkstra算法介绍"></a>Dijkstra算法介绍</h2><p><img data-src="https://img-blog.csdnimg.cn/20210623111311287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjk5NDM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(1)算法原理:从源点开始,更新每个与源点相连的点的最短距离d[i].然后每次以d[i]最小的顶点为中心,继续更新与该顶点相连的顶点的d[i],此时该点的最短距离已确定,后面不再关心该顶点.<br>如上图,顶点1为源点,把d[1]设为0,先从点1开始,更新d[2]为2,d[3]为5,除去 d[1],由于d[2]最小,因此顶点2最短距离已确定,然后从顶点2开始更新d[i]大于d[2]的顶点的最短距离,依次类推.<br>(2)时间复杂度:非优化版本为O(|V|^2^),堆优化版本为O(|V||E|)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p> <strong>1.非优化版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a,b,dn,s,t;</span><br><span class="line"><span class="type">int</span> dis[N];<span class="comment">//每个顶点到源点的最短距离</span></span><br><span class="line"><span class="type">int</span> w[N][N];<span class="comment">//每两个顶点之间边的权值</span></span><br><span class="line"><span class="comment">//初始化边权</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">               w[i][j]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> book[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">fill</span>(dis,dis+<span class="number">1</span>+n,inf);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> v=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="comment">//找到离源点最近的顶点</span></span><br><span class="line">            <span class="keyword">if</span>((v==<span class="number">-1</span>||dis[j]&lt;dis[v])&amp;&amp;!book[j])&#123;</span><br><span class="line">                v=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        book[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dis[i]=<span class="built_in">min</span>(dis[i],dis[v]+w[v][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="comment">//输入边权</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;dn;</span><br><span class="line">            w[a][b]=w[b][a]=dn;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="built_in">dijkstra</span>(s);</span><br><span class="line">        cout&lt;&lt;dis[t]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.堆优化版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,sx,a,b,w;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">vector&lt;edge&gt; G[N];<span class="comment">//邻接矩阵存储图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d+<span class="number">1</span>,d+<span class="number">1</span>+n,inf);</span><br><span class="line">    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        P q=que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> v=q.second;</span><br><span class="line">        <span class="comment">//P(d[e.to],e.to)可能多次进入队列了,因此要跳过q.first大的情况</span></span><br><span class="line">        <span class="keyword">if</span>(d[v]&lt;q.first) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[v].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            edge e=G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(d[v]+e.cost&lt;d[e.to])&#123;</span><br><span class="line">                d[e.to]=d[v]+e.cost;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">P</span>(d[e.to],e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ3Nzk=">1.P4779 【模板】单源最短路径（标准版）</span><br><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,sx,a,b,w;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">vector&lt;edge&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d+<span class="number">1</span>,d+<span class="number">1</span>+n,inf);</span><br><span class="line">    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        P q=que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> v=q.second;</span><br><span class="line">        <span class="keyword">if</span>(d[v]&lt;q.first) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[v].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            edge e=G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(d[v]+e.cost&lt;d[e.to])&#123;</span><br><span class="line">                d[e.to]=d[v]+e.cost;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">P</span>(d[e.to],e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;sx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        edge e;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;e.to&gt;&gt;e.cost;</span><br><span class="line">        G[a].<span class="built_in">push_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(sx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">            cout&lt;&lt;d[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE2Mjk=">2.P1629 邮递员送信</span><br><em>此题需反向建图</em><br><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; P;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123; <span class="type">int</span> to,cost; &#125;;</span><br><span class="line"><span class="type">int</span> n,m,u,d[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">vector&lt;edge&gt; G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d,d+n*<span class="number">2</span>+<span class="number">1</span>,inf);</span><br><span class="line">    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">0</span>,s));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        P q=que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> w=q.first,v=q.second;</span><br><span class="line">        <span class="keyword">if</span>(d[v]&lt;q.first) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[v].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            edge e=G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(d[v]+e.cost&lt;d[e.to])&#123;</span><br><span class="line">                d[e.to]=d[v]+e.cost;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">P</span>(d[e.to],e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        edge e;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;e.to&gt;&gt;e.cost;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(e);</span><br><span class="line">        edge e2;</span><br><span class="line">        e2.to=u+n,e2.cost=e.cost;</span><br><span class="line">        G[e.to+n].<span class="built_in">push_back</span>(e2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=d[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=d[n+i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序表实现归并排序</title>
    <link href="/2022/07/15/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/07/15/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>思路</strong>：分治思想，将线性表不断对半拆分，拆到只剩一个元素时就进行从小到大归并，递归实现<br><strong>代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE  200 <span class="comment">//线性表存储空间的初始分配量 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT   20 <span class="comment">//线性表存储空间的分配增量 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType *elem;<span class="comment">//存储空间基址</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line"><span class="type">int</span> listsize;<span class="comment">//当前分配的存储容量</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="comment">//构造一个空的线性表L</span></span><br><span class="line">L.elem=(ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line"><span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">L.length=<span class="number">0</span>;<span class="comment">//空表长度为0</span></span><br><span class="line">L.listsize=LIST_INIT_SIZE;<span class="comment">//初始存储容量</span></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line"><span class="comment">//在顺序表L中第i个位置之前插入新的元素e</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.listsize+<span class="number">1</span>) <span class="keyword">return</span>  ERROR; <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">if</span>(L.length&gt;=L.listsize)&#123;<span class="comment">//当前存储空间已满,增加分配</span></span><br><span class="line">ElemType *newbase=(ElemType*)<span class="built_in">realloc</span>(L.elem,(L.listsize+LISTINCREMENT)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line"><span class="keyword">if</span>(!newbase) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">L.elem=newbase;<span class="comment">//新基址 </span></span><br><span class="line">L.listsize+=LISTINCREMENT;<span class="comment">//增加存储容量 </span></span><br><span class="line">&#125;</span><br><span class="line">ElemType *q=&amp;(L.elem[i<span class="number">-1</span>]),*p;</span><br><span class="line"><span class="keyword">for</span>(p=&amp;(L.elem[L.length<span class="number">-1</span>]);p&gt;=q;--p) *(p+<span class="number">1</span>)=*p;</span><br><span class="line">*q=e;</span><br><span class="line">++L.length;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListInsert_Sq</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La,SqList Lb,SqList &amp;Lc)</span></span>&#123;</span><br><span class="line"><span class="comment">//已知顺序线性表La和Lb的元素按值非递减排列</span></span><br><span class="line"><span class="comment">//归并La和Lb得到新的顺序线性表Lc,Lc的元素也按值非递减排列</span></span><br><span class="line">ElemType *pa,*pb,*pc,*pa_last,*pb_last;</span><br><span class="line">pa=La.elem;pb=Lb.elem;</span><br><span class="line">Lc.listsize=Lc.length=La.length+Lb.length;</span><br><span class="line">pc=Lc.elem=(ElemType*)<span class="built_in">malloc</span>(Lc.listsize*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line"><span class="keyword">if</span>(!Lc.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">pa_last=La.elem+La.length<span class="number">-1</span>;</span><br><span class="line">pb_last=Lb.elem+Lb.length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(pa&lt;=pa_last&amp;&amp;pb&lt;=pb_last)&#123;</span><br><span class="line"><span class="keyword">if</span>(*pa&lt;=*pb) *pc++=*pa++;</span><br><span class="line"><span class="keyword">else</span> *pc++=*pb++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(pa&lt;=pa_last)*pc++=*pa++;</span><br><span class="line"><span class="keyword">while</span>(pb&lt;=pb_last)*pc++=*pb++;</span><br><span class="line">&#125;<span class="comment">//MergeList_Sq</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList_Sq</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line"><span class="comment">//输出线性表L中的元素 </span></span><br><span class="line">ElemType *p;</span><br><span class="line"><span class="keyword">for</span>(p=L.elem;p&lt;L.elem+L.length;++p)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//PrintList_Sq</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DivList</span><span class="params">(SqList L,SqList &amp;La,SqList &amp;Lb)</span></span>&#123;</span><br><span class="line"><span class="comment">//将线性表L对半分解成两个线性表 </span></span><br><span class="line"><span class="keyword">if</span>(L.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">ElemType *p,*pa,*pb;</span><br><span class="line">La.listsize=La.length=L.length/<span class="number">2</span>;</span><br><span class="line">Lb.listsize=Lb.length=L.length-La.length;</span><br><span class="line">pa=La.elem=(ElemType*)<span class="built_in">malloc</span>(La.listsize*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">pb=Lb.elem=(ElemType*)<span class="built_in">malloc</span>(Lb.listsize*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line"><span class="keyword">for</span>(p=L.elem;p&lt;=&amp;(L.elem[La.length<span class="number">-1</span>]);)</span><br><span class="line">*pa++=*p++;</span><br><span class="line"><span class="keyword">while</span>(p&lt;=&amp;(L.elem[L.length<span class="number">-1</span>])) *pb++=*p++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_Sort</span><span class="params">(SqList L,SqList &amp;Ls)</span></span>&#123;</span><br><span class="line"><span class="comment">//归并排序,排序后的线性表为Ls</span></span><br><span class="line"><span class="keyword">if</span>(L.length==<span class="number">1</span>)&#123;<span class="comment">//当线性表被拆到只有一个元素时,结束递归 </span></span><br><span class="line">Ls=L;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">SqList La,Lb,Lc,Ld;</span><br><span class="line"><span class="built_in">DivList</span>(L,La,Lb);<span class="comment">//将线性表L拆分成La和Lb </span></span><br><span class="line"><span class="built_in">Merge_Sort</span>(La,Lc);</span><br><span class="line"><span class="built_in">Merge_Sort</span>(Lb,Ld);</span><br><span class="line"><span class="built_in">MergeList_Sq</span>(Lc,Ld,Ls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqList L,La,Lb,Ls;</span><br><span class="line"><span class="built_in">InitList_Sq</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">a=<span class="built_in">rand</span>()%<span class="number">200</span>;<span class="comment">//产生0到199之间的随机数进行测试 </span></span><br><span class="line"><span class="built_in">ListInsert_Sq</span>(L,i,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始序列:\n&quot;</span>);</span><br><span class="line"><span class="built_in">PrintList_Sq</span>(L);</span><br><span class="line"><span class="built_in">Merge_Sort</span>(L,Ls);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的序列:\n&quot;</span>);</span><br><span class="line"><span class="built_in">PrintList_Sq</span>(Ls);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Acwing4310.树的DFS(dfs序列)</title>
    <link href="/2022/07/15/Acwing4310-%E6%A0%91%E7%9A%84DFS/"/>
    <url>/2022/07/15/Acwing4310-%E6%A0%91%E7%9A%84DFS/</url>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDMxMy8=">题目链接</span></h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用dfs跑一遍整棵树,分别用一个数组记录好每个结点的dfs序(dfn数组),整棵树的dfs序列(p数组),以每个不同节点为根节点的子树节点数量(sz数组).<br>若询问时输入u,k,当k&gt;sz[u]时无解,否则答案为p[dfn[u]+k-1].</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bug(a) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bugg(a,b) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buggg(a,b,c) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; P;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> dfn[N],p[N],top,sz[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=top,p[top]=u;</span><br><span class="line">    top++;</span><br><span class="line">    sz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">        g[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++) sort(g[i].begin(),g[i].end());</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> u,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(k&gt;sz[u])</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[dfn[u]+k<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组总结</title>
    <link href="/2022/07/15/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/15/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="一、树状数组介绍"><a href="#一、树状数组介绍" class="headerlink" title="一、树状数组介绍"></a>一、树状数组介绍</h1><p>树状数组是一种用数组模拟的树形结构，修改和查询的复杂度都是<strong>O(logN)</strong>,常用于解决区间更新以及求和问题.<br><img data-src="https://img-blog.csdnimg.cn/6c7285b44ce545269b1926560b6d1610.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASFozNTU3Mg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上图中:<br>C[1] &#x3D; A[1];<br>C[2] &#x3D; A[1] + A[2];<br>C[3] &#x3D; A[3];<br>C[4] &#x3D; A[1] + A[2] + A[3] + A[4];<br>C[5] &#x3D; A[5];<br>C[6] &#x3D; A[5] + A[6];<br>C[7] &#x3D; A[7];<br>C[8] &#x3D; A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];<br>由此可得这颗树的规律:<br>C[i]&#x3D;A[i-$2^k$+1]+A[i-$2^k$+2]+…+A[i],其中k为i的二进制中从最低位到高位连续零的长度,$2^k$也叫lowbit,可以利用位运算计算,如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><p>树状数组的<strong>单点修改</strong>,<strong>单点查询</strong>和<strong>区间查询</strong>的完整代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bug(a) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bugg(a,b) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buggg(a,b,c) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>,<span class="type">double</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[N],c[N];<span class="comment">//对应原数组和树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span></span>&#123; <span class="comment">//在i位置加上k</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        c[i]+=k;</span><br><span class="line">        i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;  <span class="comment">//求前i项的和</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res+=c[i];</span><br><span class="line">        i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;A[i];</span><br><span class="line">        <span class="built_in">updata</span>(i,A[i]);<span class="comment">//第i个位置加上A[i]；</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">getsum</span>(<span class="number">3</span>)&lt;&lt;endl;<span class="comment">//求前三项的和</span></span><br><span class="line">    <span class="built_in">updata</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//把第二个元素加上2</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">getsum</span>(<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">getsum</span>(<span class="number">4</span>)-<span class="built_in">getsum</span>(<span class="number">1</span>)&lt;&lt;endl;<span class="comment">//求区间2~4之间的和</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">getsum</span>(<span class="number">2</span>)-<span class="built_in">getsum</span>(<span class="number">1</span>)&lt;&lt;endl;<span class="comment">//求第二个元素的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区间修改,单点查询</strong>则需要借助差分数组,完整代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bug(a) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bugg(a,b) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buggg(a,b,c) cout&lt;&lt;<span class="string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>,<span class="type">double</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll A[N],c[N];<span class="comment">//对应原数组和树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> i,ll k)</span></span>&#123; <span class="comment">//在i位置加上k</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        c[i]+=k;</span><br><span class="line">        i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;  <span class="comment">//求d数组前i项的和，也就是A[i]的值</span></span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res+=c[i];</span><br><span class="line">        i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;A[i];</span><br><span class="line">        <span class="built_in">updata</span>(i,A[i]-A[i<span class="number">-1</span>]);<span class="comment">//第i个位置加上d[i]；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> opt;</span><br><span class="line">        cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">getsum</span>(x)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> l,r,d;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r&gt;&gt;d;<span class="comment">//把区间l~r之间每个元素都加上d</span></span><br><span class="line">            <span class="built_in">updata</span>(l,d);</span><br><span class="line">            <span class="built_in">updata</span>(r+<span class="number">1</span>,-d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>区间修改，区间查询</strong>,原理如下:<br>设d[i]为原数组的差分数组,则可推导出原数组前n项和满足下面公式:<br>$$\sum_{i&#x3D;1}^{n}a[i]&#x3D;\sum_{i&#x3D;1}^{n}d[i]-\sum_{i&#x3D;1}^{n}(i-1)*d[i]$$</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n,a[N],sum1[N],sum2[N];</span><br><span class="line"><span class="comment">//sum1[i]:d[i],sum2[i]:(i-1)*d[i]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> i,ll x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//单点修改</span></span><br><span class="line">    ll p1=i;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        sum1[i]+=x;</span><br><span class="line">        sum2[i]+=x*(p1<span class="number">-1</span>);</span><br><span class="line">        i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">range_up</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,ll x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//使区间l到r中每一个数都加上x</span></span><br><span class="line">    <span class="built_in">updata</span>(l,x);</span><br><span class="line">    <span class="built_in">updata</span>(r+<span class="number">1</span>,-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求前i项和</span></span><br><span class="line">    ll res=<span class="number">0</span>,p=i;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res+=p*sum1[i]-sum2[i];</span><br><span class="line">        i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">range_sum</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//区间求和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getsum</span>(r)-<span class="built_in">getsum</span>(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">updata</span>(i,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">getsum</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">range_up</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">getsum</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">range_up</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">range_sum</span>(<span class="number">1</span>,<span class="number">4</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树基本操作</title>
    <link href="/2022/07/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/07/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的创建和基本操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK       1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW  -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BitNode</span>&#123;</span><br><span class="line">      TElemType data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BitNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BitNode,*BitTree;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateBitTree</span><span class="params">(BitTree &amp;T)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一颗二叉树T，按先序遍历的方式创建</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>) T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!(T=(BitNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BitNode))))  <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreateBitTree</span>(T-&gt;lchild);</span><br><span class="line"><span class="built_in">CreateBitTree</span>(T-&gt;rchild);</span><br><span class="line">&#125;<span class="comment">//if</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//CreateBitTree</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line"><span class="comment">//先序遍历二叉树T</span></span><br><span class="line"><span class="keyword">if</span>(!T) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,T-&gt;data);</span><br><span class="line"><span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">&#125;<span class="comment">//PreOrderTraverse</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line"><span class="comment">//中序遍历二叉树T</span></span><br><span class="line"><span class="keyword">if</span>(!T) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,T-&gt;data);</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">&#125;<span class="comment">//InOrderTraverse</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line"><span class="comment">//后序遍历二叉树T</span></span><br><span class="line"><span class="keyword">if</span>(!T) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,T-&gt;data);</span><br><span class="line">&#125;<span class="comment">//InOrderTraverse</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountNode</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line"><span class="comment">//求二叉树T的结点总数</span></span><br><span class="line"><span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CountNode</span>(T-&gt;lchild)+<span class="built_in">CountNode</span>(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//CountNode</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyMax</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;<span class="comment">//MyMax</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetHigh</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line"><span class="comment">//求二叉树T的高度</span></span><br><span class="line"><span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">MyMax</span>(<span class="built_in">GetHigh</span>(T-&gt;lchild),<span class="built_in">GetHigh</span>(T-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//GetHigh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountLeafNode</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line"><span class="comment">//求二叉树T的叶子结点总数</span></span><br><span class="line"><span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!T-&gt;lchild&amp;&amp;!T-&gt;rchild) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CountLeafNode</span>(T-&gt;lchild)+<span class="built_in">CountLeafNode</span>(T-&gt;rchild);</span><br><span class="line">&#125;<span class="comment">//CountNode</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">   BitTree T;</span><br><span class="line">   <span class="built_in">CreateBitTree</span>(T);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n先序遍历:&quot;</span>);</span><br><span class="line">   <span class="built_in">PreOrderTraverse</span>(T);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历:&quot;</span>);</span><br><span class="line">   <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历:&quot;</span>);</span><br><span class="line">   <span class="built_in">PostOrderTraverse</span>(T);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的结点数为:%d&quot;</span>,<span class="built_in">CountNode</span>(T));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的高度为:%d&quot;</span>,<span class="built_in">GetHigh</span>(T));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的叶子结点数为:%d&quot;</span>,<span class="built_in">CountLeafNode</span>(T));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小互质数(欧拉筛)</title>
    <link href="/2022/07/15/%E6%9C%80%E5%B0%8F%E4%BA%92%E8%B4%A8%E6%95%B0/"/>
    <url>/2022/07/15/%E6%9C%80%E5%B0%8F%E4%BA%92%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们定义两个数的互质数当且仅当gcd(a, b) &#x3D; 1。<br>现在L手里有n个数，分别为a1，a2，a3 ……an-1，an  。<br>问，没有在这n个数中出现过并且与这n个数都互质的最小的数是多少。<br>LL觉得这个问题太简单了，于是她把这个问题交给你来解决<br><strong>输入</strong><br>第一行一个数n (1 ≤ n, ai ≤ 10^5)<br>接下来n行，每行一个数，分别代表a1，a2，a3 ……an-1，an  。<br><strong>输出</strong><br>输出一行代表答案<br><strong>样例输入</strong><br>5<br>1<br>2<br>3<br>4<br>5<br><strong>样例输出</strong><br>7</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>   这道题如果用暴力破解肯定会TLE，所以我是先用欧拉筛法标记好10^6以内的素数。然后再用sort函数给输入的数据排好序，从1开始按顺序一一往后查找，只要一出现数组中没有的数，就判断是否是质数（利用前面欧拉筛法标记好的的素数数组），如果是质数，就判断其是不是数组中出现过的数的约数，如果不是那么这个数就是答案，如果是，就继续往后找。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prim[N],a[N],i,j,k,n,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> isp[N]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//欧拉筛法求2~N之间的素数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isp[i]) prim[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prim[j]&gt;N) <span class="keyword">break</span>;</span><br><span class="line">            isp[i*prim[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//如果数组中最小的数不是1，则这n个数的最小互质数肯定为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>,k=<span class="number">2</span>;;i++,k++)&#123;</span><br><span class="line">        <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[i+<span class="number">1</span>]!=k+<span class="number">1</span>)&#123;<span class="comment">//如果a[i+1]!=k+1,则k+1是这个有序数组没有出现过的数</span></span><br><span class="line">            <span class="keyword">if</span>(!isp[k+<span class="number">1</span>])&#123;<span class="comment">//判断是否为素数</span></span><br><span class="line">                <span class="keyword">if</span>(k+<span class="number">1</span>&gt;a[n])&#123;<span class="comment">//如果k+1大于数组里最大的数，那么它肯定不可能是数组里任何一个数的约数</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//判断数组里有没有数能被k+1整除</span></span><br><span class="line">                    <span class="keyword">if</span>(a[j]%(k+<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;n)&#123;<span class="comment">//数组内没有数能被k+1整除，输出k+1</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;<span class="comment">//若不符合最小互质数条件，则继续往后查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/13/hello-world/"/>
    <url>/2022/07/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo</span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting</span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub</span>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing</span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server</span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating</span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="updata-github"><a href="#updata-github" class="headerlink" title="updata github"></a>updata github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment</span></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
