<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>零一万物：Yi Model API的使用</title>
    <link href="/2024/07/02/%E9%9B%B6%E4%B8%80%E4%B8%87%E7%89%A9/"/>
    <url>/2024/07/02/%E9%9B%B6%E4%B8%80%E4%B8%87%E7%89%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="一、获取API-Key"><a href="#一、获取API-Key" class="headerlink" title="一、获取API Key"></a>一、获取API Key</h1><ol><li><p>通过官方网址注册账号并且认证: <a href="https://platform.lingyiwanwu.com/docs">零一万物大模型开放平台 </a></p><p><img src="D:\Blog\source\assets\img\post8\img1.png"></p></li><li><p>创建API Key</p><p><img src="D:\Blog\source\assets\img\post8\img2.png"></p></li></ol><h1 id="二、安装及调用"><a href="#二、安装及调用" class="headerlink" title="二、安装及调用"></a>二、安装及调用</h1><p><strong>安装OpenAI SDK</strong></p><p>​零一万物API 接口兼容 OpenAI 的 Python SDK，只需要简单配置即可使用。</p><p>安装 OpenAI SDK。请确保使用的 Python 版本至少为 3.7.1，OpenAI SDK 版本不低于 1.0.0。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install openai<br></code></pre></td></tr></table></figure><p><strong>调用示例一: 同步调用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openai<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br>API_BASE = <span class="hljs-string">&quot;https://api.lingyiwanwu.com/v1&quot;</span><br>API_KEY = <span class="hljs-string">&quot;your key&quot;</span><br>client = OpenAI(<br>  api_key=API_KEY,<br>  base_url=API_BASE<br>)<br>completion = client.chat.completions.create(<br>  model=<span class="hljs-string">&quot;yi-large-turbo&quot;</span>,<br>  messages=[&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;Hi, who are you?&quot;</span>&#125;]<br>)<br><span class="hljs-built_in">print</span>(completion)<br><br></code></pre></td></tr></table></figure><p><strong>调用示例二: 流式调用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openai<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br>API_BASE = <span class="hljs-string">&quot;https://api.lingyiwanwu.com/v1&quot;</span><br>API_KEY = <span class="hljs-string">&quot;your key&quot;</span><br>client = OpenAI(<br>  api_key=API_KEY,<br>  base_url=API_BASE<br>)<br>completion = client.chat.completions.create(<br>  model=<span class="hljs-string">&quot;yi-large&quot;</span>,<br>  messages=[&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;Hi, who are you?&quot;</span>&#125;],<br>  stream=<span class="hljs-literal">True</span><br>)<br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> completion:<br>  <span class="hljs-built_in">print</span>(chunk.choices[<span class="hljs-number">0</span>].delta.content <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;&quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>, flush=<span class="hljs-literal">True</span>)<br><br></code></pre></td></tr></table></figure><p>更多调用详情参考官方文档: <a href="https://platform.lingyiwanwu.com/docs">零一万物大模型接口文档</a></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智谱AI：ChatGLM API的使用</title>
    <link href="/2024/07/01/%E8%B4%A8%E8%B0%B1AI/"/>
    <url>/2024/07/01/%E8%B4%A8%E8%B0%B1AI/</url>
    
    <content type="html"><![CDATA[<h1 id="一、获取API-Key"><a href="#一、获取API-Key" class="headerlink" title="一、获取API Key"></a>一、获取API Key</h1><p>1、打开网址：<a href="https://open.bigmodel.cn/overview">智谱AI开放平台</a> 注册账号登录</p><p>2、登录，查看API key (注册后赠送100万token，实名认证后多赠送400万, 有效期一个)</p><p><img src="/../assets/img/post7/img1.png"></p><p><img src="D:\Blog\source\assets\img\post7\img2.png"></p><h1 id="二、安装及调用"><a href="#二、安装及调用" class="headerlink" title="二、安装及调用"></a>二、安装及调用</h1><p><strong>安装质谱SDK</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install zhipuai<br></code></pre></td></tr></table></figure><p><strong>调用方式</strong></p><ol><li><p>流式调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> zhipuai <span class="hljs-keyword">import</span> ZhipuAI<br>client = ZhipuAI(api_key=<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment"># 请填写您自己的APIKey</span><br>response = client.chat.completions.create(<br>  model=<span class="hljs-string">&quot;glm-4&quot;</span>,  <span class="hljs-comment"># 填写需要调用的模型名称</span><br>    messages=[<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;你好！你叫什么名字&quot;</span>&#125;,<br>    ],<br>    stream=<span class="hljs-literal">True</span>,<br>    )<br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response:<br>    <span class="hljs-built_in">print</span>(chunk.choices[<span class="hljs-number">0</span>].delta)<br></code></pre></td></tr></table></figure></li><li><p>非流式调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> zhipuai <span class="hljs-keyword">import</span> ZhipuAI<br>client = ZhipuAI(api_key=<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment"># 填写您自己的APIKey</span><br>response = client.chat.completions.create(<br>    model=<span class="hljs-string">&quot;glm-4&quot;</span>,  <span class="hljs-comment"># 填写需要调用的模型名称</span><br>    messages=[<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;作为一名营销专家，请为我的产品创作一个吸引人的slogan&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;当然，为了创作一个吸引人的slogan，请告诉我一些关于您产品的信息&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;智谱AI开放平台&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;智启未来，谱绘无限一智谱AI，让创新触手可及!&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;创造一个更精准、吸引人的slogan&quot;</span>&#125;<br>    ],<br>)<br><span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].message)<br></code></pre></td></tr></table></figure></li></ol><p>具体调用参数可参考官方文档: <a href="https://open.bigmodel.cn/dev/api#language">智谱AI接口文档</a></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/15/hello-world/"/>
    <url>/2024/06/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><h3 id="updata-github"><a href="#updata-github" class="headerlink" title="updata github"></a>updata github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2024/02/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/02/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、文件操作"><a href="#一、文件操作" class="headerlink" title="一、文件操作"></a>一、文件操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">- touch aa.txt<br>- rm -rf  aa.txt<br>- vi aa.txt<br>- cat aa.txt<br></code></pre></td></tr></table></figure><h1 id="二、目录操作"><a href="#二、目录操作" class="headerlink" title="二、目录操作"></a>二、目录操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir aaa# 建目录aaa<br>rm -rf aaa # 删除 aaa目录<br>mv a.txt /var/log/mysql/b.txt # 将a.txt文件移动到mysql目录下并名改为b.txt <br>cp /usr/tmp/aaa /usr/ # 将aaa文件copy到usr下<br>find /usr/tmp -name &#x27;a*&#x27; # 查找/usr/tmp目录下的所有以a开头的目录或文件<br>pwd# 查看当前所在目录<br></code></pre></td></tr></table></figure><h1 id="三、高阶指令"><a href="#三、高阶指令" class="headerlink" title="三、高阶指令"></a>三、高阶指令</h1><p><strong>权限修改</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 746 aaa.txt   chmod +x aaa.txt<br>7 4 6<br>   421  421  421<br><br> rwx   r--     rw-       文件的权限 <br> d  rwx   r--     rw-       目录的权限<br>   用户   用户所在组  其他用户<br></code></pre></td></tr></table></figure><p><strong>查看进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">top # 实时查看运行内存、cpu利用率<br>ps -ef # 非实时查看<br>ps -ef | grep ping<br></code></pre></td></tr></table></figure><p><strong>结束进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -9 9888 # 强制杀掉进程号为9888的进程<br>pkill -f mysql   # 结束进程名称为“mysql”的所有进程<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt配置OpenCV(包括contrib模块)</title>
    <link href="/2024/01/23/Qt%E9%85%8D%E7%BD%AEOpenCV/"/>
    <url>/2024/01/23/Qt%E9%85%8D%E7%BD%AEOpenCV/</url>
    
    <content type="html"><![CDATA[<p>首先安装好Qt Createor，CMake，OpenCV,我本次使用的是Qt5.15.2和OpenCV4.6.0,</p><ul><li>Qt Creator清华镜像源:<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/qtcreator/">https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/qtcreator/</a></li><li>OpenCV官网下载: <a href="https://opencv.org/releases/">https://opencv.org/releases/</a></li></ul><h1 id="一-编译OpenCV"><a href="#一-编译OpenCV" class="headerlink" title="一. 编译OpenCV"></a>一. 编译OpenCV</h1><ol><li>首先使用Qt Creator打开OpenCV的sources项目，选择sources中的CMakeList.txt，然后打开：<br><img src="/../assets/img/post5/img1.png"><br>之后会出现一个 Configure Project 窗口，配置编译时产生的中间文件保存的路径，这些不用改，直接点击 Configure Project 按钮。</li><li>打开后进入“项目“，在“编辑构建配置”处选择“Release”：<br><img src="/../assets/img/post5/img2.png"><br><img src="/../assets/img/post5/img3.png"><br>然后等几分钟，这段时间 Qt 正在读取 CMakeLists.txt 文件，当在概要信息看到 Configuring done 和 Generating done 就读取完了。<br><img src="/../assets/img/post5/img4.png"></li><li>进入“项目”，找到 CMAKE_INSTALL_PREFIX，设置一个路径，这个路径是编译完成后输出的路径。其他配置保持默认。<br><img src="/../assets/img/post5/img5.png"><br>如果要安装contrib模块，还要在DOPENCV_EXTRA_MODULES_PATH这个选项设置contrib的modules文件夹所在路径<br><img src="/../assets/img/post5/img14.png"></li><li>再到构建步骤，详情，勾选install，然后点右下角的“锤子”,开始构建。构建过程要保持网络通畅，因为构建时会下载部分文件。这个过程会花半个小时左右，当“编译输出”中显示“正常退出”，表示构建成功，在 CMAKE_INSTALL_PREFIX 路径中可以看到产生的文件。如果编译失败，则换个opencv版本，重新尝试。<br><img src="/../assets/img/post5/img6.png"><br><img src="/../assets/img/post5/img7.png"></li></ol><h1 id="二-配置OpenCV开发环境"><a href="#二-配置OpenCV开发环境" class="headerlink" title="二. 配置OpenCV开发环境"></a>二. 配置OpenCV开发环境</h1><p>编译好的opencv会有以下这些文件夹，把这些文件放到合适的位置。<br><img src="/../assets/img/post5/img8.png"></p><ol><li><p>配置OpenCV环境<br>对计算机右键-&gt;属性-&gt;高级系统配置-&gt;环境变量&gt;Path 变量里加入 opencv 的 bin 文件夹的路径<br><img src="/../assets/img/post5/img9.png"><br>还要编译后bin目录中的dll文件复制到Qt&#x2F;6.2.4&#x2F;mingw_64&#x2F;bin目录中<br><img src="/../assets/img/post5/img11.png"><br><img src="/../assets/img/post5/img12.png"></p></li><li><p>新建一个Qt控制台项目，给qt项目添加头文件路径和静态库路径<br>在.pro文件中添加以下代码。每次新建项目都要添。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">INCLUDEPATH+=D:<span class="hljs-regexp">/opencv2/</span>opencv<span class="hljs-regexp">/install/i</span>nclude \<br>            D:<span class="hljs-regexp">/opencv2/</span>opencv<span class="hljs-regexp">/install/i</span>nclude/opencv<br>            D:<span class="hljs-regexp">/opencv2/</span>opencv<span class="hljs-regexp">/install/i</span>nclude/opencv2<br><br>LIBS+=D:<span class="hljs-regexp">/opencv2/</span>opencv<span class="hljs-regexp">/install/</span>x64<span class="hljs-regexp">/mingw/</span>lib/libopencv_*<br></code></pre></td></tr></table></figure><p><img src="/../assets/img/post5/img10.png"></p></li></ol><h1 id="三-测试"><a href="#三-测试" class="headerlink" title="三. 测试"></a>三. 测试</h1><p>在新建项目的main.cpp文件中写下以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; endl;<br>    Mat img = <span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;E:/computer/C++_plan/Qt_program/cvTest/2.jpg&quot;</span>);<br>    Mat reimg;<br>    <span class="hljs-built_in">resize</span>(img, reimg, &#123; <span class="hljs-number">900</span>, <span class="hljs-number">512</span> &#125;);<br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;test&quot;</span>, reimg);<br>    <span class="hljs-built_in">waitKey</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>点击运行按钮，图片显示出来即可。<br><img src="/../assets/img/post5/img13.png"></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程同步</title>
    <link href="/2023/01/03/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/01/03/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程同步的概念"><a href="#一、线程同步的概念" class="headerlink" title="一、线程同步的概念"></a>一、线程同步的概念</h1><p>首先，观察以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREAD 100</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> thread_id[NUM_THREAD];<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof long long: %d \n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>));<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_THREAD; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>)<br>            pthread_create(&amp;(thread_id[i]), <span class="hljs-literal">NULL</span>, thread_inc, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">else</span><br>            pthread_create(&amp;(thread_id[i]), <span class="hljs-literal">NULL</span>, thread_des, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_THREAD; i++)<br>        pthread_join(thread_id[i], <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %lld \n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码运行结果为：<br><img src="/../assets/img/post2/fig1.png" alt="thread4.c运行结果"><br>从图上可以看出，每次运行的结果竟然不一样。理论上来说，上面代码的最后结果应该是 0 。<br>以上程序问题如下：</p><blockquote><p>2 个线程正在同时访问全局变量 num</p></blockquote><p>任何内存空间，只要被同时访问，都有可能发生问题。</p><p>因此，线程访问变量 num 时应该阻止其他线程访问，直到线程 1 运算完成。这就是同步（Synchronization）</p><p>临界区可以定义为如下形式：</p><blockquote><p>函数内同时运行多个线程时引发问题的多条语句构成的代码块</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num += <span class="hljs-number">1</span>;<span class="hljs-comment">//临界区</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000000</span>; i++)<br>        num -= <span class="hljs-number">1</span>;<span class="hljs-comment">//临界区</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上述代码可知，临界区并非 num 本身，而是访问 num 的两条语句，这两条语句可能由多个线程同时运行，也是引起这个问题的直接原因。产生问题的原因可以分为以下三种情况：</p><blockquote><ul><li>2 个线程同时执行 thread_inc 函数</li><li>2 个线程同时执行 thread_des 函数</li><li>2 个线程分别执行 thread_inc 和 thread_des 函数</li></ul></blockquote><p>也就是说，两条不同的语句由不同的线程执行时，也有可能构成临界区。前提是这 2 条语句访问同一内存空间。</p><h1 id="二、线程同步的方式"><a href="#二、线程同步的方式" class="headerlink" title="二、线程同步的方式"></a>二、线程同步的方式</h1><h2 id="1、互斥量"><a href="#1、互斥量" class="headerlink" title="1、互斥量"></a>1、互斥量</h2><p>互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全域变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p><p>通俗的说就互斥量就是一把优秀的锁，当临界区被占据的时候就上锁，等占用完毕然后再放开。</p><p>下面是互斥量的创建及销毁函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex,</span><br><span class="hljs-params">                       <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0，失败时返回其他值</span><br><span class="hljs-comment">mutex : 创建互斥量时传递保存互斥量的变量地址值，销毁时传递需要销毁的互斥量地址</span><br><span class="hljs-comment">attr : 传递即将创建的互斥量属性，没有特别需要指定的属性时传递 NULL</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>从上述函数声明中可以看出，为了创建相当于锁系统的互斥量，需要声明如下 pthread_mutex_t 型变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> mutex<br></code></pre></td></tr></table></figure><p>该变量的地址值传递给 pthread_mutex_init 函数，用来保存操作系统创建的互斥量（锁系统）。调用 pthread_mutex_destroy 函数时同样需要该信息。如果不需要配置特殊的互斥量属性，则向第二个参数传递 NULL 时，可以利用 PTHREAD_MUTEX_INITIALIZER 进行如下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br></code></pre></td></tr></table></figure><p>推荐尽可能的使用 pthread_mutex_init 函数进行初始化，因为通过宏进行初始化时很难发现发生的错误。<br>下面是利用互斥量锁住或释放临界区时使用的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回其他值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>函数本身含有 lock unlock 等词汇，很容易理解其含义。进入临界区前调用的函数就是 pthread_mutex_lock 。调用该函数时，发现有其他线程已经进入临界区，则 pthread_mutex_lock 函数不会返回，直到里面的线程调用 pthread_mutex_unlock 函数退出临界区位置。也就是说，其他线程让出临界区之前，当前线程一直处于阻塞状态。接下来整理一下代码的编写方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">pthread_mutex_lock(&amp;mutex);<br><span class="hljs-comment">//临界区开始</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//临界区结束</span><br>pthread_mutex_unlock(&amp;mutex);<br></code></pre></td></tr></table></figure><p>简言之，就是利用 lock 和 unlock 函数围住临界区的两端。此时互斥量相当于一把锁，阻止多个线程同时访问，还有一点要注意，线程退出临界区时，如果忘了调用 pthread_mutex_unlock 函数，那么其他为了进入临界区而调用 pthread_mutex_lock 的函数无法摆脱阻塞状态。这种情况称为「死锁」。需要格外注意，下面是利用互斥量解决示例 thread4.c 中遇到的问题代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREAD 100</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">pthread_mutex_t</span> mutex; <span class="hljs-comment">//保存互斥量读取值的变量</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> thread_id[NUM_THREAD];<br>    <span class="hljs-type">int</span> i;<br><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//创建互斥量</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_THREAD; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>)<br>            pthread_create(&amp;(thread_id[i]), <span class="hljs-literal">NULL</span>, thread_inc, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">else</span><br>            pthread_create(&amp;(thread_id[i]), <span class="hljs-literal">NULL</span>, thread_des, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_THREAD; i++)<br>        pthread_join(thread_id[i], <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %lld \n&quot;</span>, num);<br>    pthread_mutex_destroy(&amp;mutex); <span class="hljs-comment">//销毁互斥量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_inc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">//上锁</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000000</span>; i++)<br>        num += <span class="hljs-number">1</span>;<br>    pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">//解锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_des</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    pthread_mutex_lock(&amp;mutex);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000000</span>; i++)<br>        num -= <span class="hljs-number">1</span>;<br>    pthread_mutex_unlock(&amp;mutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="/../assets/img/post2/fig2.png" alt="mutex.c运行结果"><br>从运行结果可以看出，通过互斥量机制得出了正确的运行结果。</p><h2 id="2、信号量"><a href="#2、信号量" class="headerlink" title="2、信号量"></a>2、信号量</h2><p>信号量（英语：Semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态.</p><p>semaphore对象适用于控制一个仅支持有限个用户的共享资源，是一种不需要使用忙碌等待（busy waiting）的方法。</p><p>信号量的概念是由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex）。</p><p>下面介绍信号量，在互斥量的基础上，很容易理解信号量。此处只涉及利用「二进制信号量」（只用 0 和 1）完成「控制线程顺序」为中心的同步方法。下面是信号量的创建及销毁方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回其他值</span><br><span class="hljs-comment">sem : 创建信号量时保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值</span><br><span class="hljs-comment">pshared : 传递其他值时，创建可由多个进程共享的信号量；传递 0 时，创建只允许 1 个进程内部使用的信号量。需要完成同一进程的线程同步，故为0</span><br><span class="hljs-comment">value : 指定创建信号量的初始值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>上述的 pshared 参数超出了我们的关注范围，故默认向其传递为 0 。下面是信号量中相当于互斥量 lock unlock 的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回其他值</span><br><span class="hljs-comment">sem : 传递保存信号量读取值的变量地址值，传递给 sem_post 的信号量增1，传递给 sem_wait 时信号量减一</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>调用 sem_init 函数时，操作系统将创建信号量对象，此对象中记录这「信号量值」（Semaphore Value）整数。该值在调用 sem_post 函数时增加 1 ，调用 wait_wait 函数时减一。但信号量的值不能小于 0 ，因此，在信号量为 0 的情况下调用 sem_wait 函数时，调用的线程将进入阻塞状态（因为函数未返回）。当然，此时如果有其他线程调用 sem_post 函数，信号量的值将变为 1 ，而原本阻塞的线程可以将该信号重新减为 0 并跳出阻塞状态。实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区（假设信号量的初始值为 1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">sem_wait(&amp;sem);<span class="hljs-comment">//信号量变为0...</span><br><span class="hljs-comment">// 临界区的开始</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//临界区的结束</span><br>sem_post(&amp;sem);<span class="hljs-comment">//信号量变为1...</span><br></code></pre></td></tr></table></figure><p>上述代码结构中，调用 sem_wait 函数进入临界区的线程在调用 sem_post 函数前不允许其他线程进入临界区。信号量的值在 0 和 1 之间跳转，因此，具有这种特性的机制称为「二进制信号量」。接下来的代码是信号量机制的代码。下面代码并非是同时访问的同步，而是关于控制访问顺序的同步，该场景为：</p><blockquote><p>线程 A 从用户输入得到值后存入全局变量 num ，此时线程 B 将取走该值并累加。该过程一共进行 5 次，完成后输出总和并退出程序。</p></blockquote><p>下面是代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">accu</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">sem_t</span> sem_one;<br><span class="hljs-type">static</span> <span class="hljs-type">sem_t</span> sem_two;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> &#123;<br>    <br>    <span class="hljs-type">pthread_t</span> id_t1, id_t2;<br>    sem_init(&amp;sem_one, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    sem_init(&amp;sem_two, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>    pthread_create(&amp;id_t1, <span class="hljs-literal">NULL</span>, read, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;id_t2, <span class="hljs-literal">NULL</span>, accu, <span class="hljs-literal">NULL</span>);<br><br>    pthread_join(id_t1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(id_t2, <span class="hljs-literal">NULL</span>);<br><br>    sem_destroy(&amp;sem_one);<br>    sem_destroy(&amp;sem_two);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Input num: &quot;</span>, <span class="hljs-built_in">stdout</span>);<br><br>        sem_wait(&amp;sem_two);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>        sem_post(&amp;sem_one);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">accu</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        sem_wait(&amp;sem_one);<br>        sum += num;<br>        sem_post(&amp;sem_two);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result: %d \n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="/../assets/img/post2/fig3.png" alt="在这里插入图片描述"></p><p>从上述代码可以看出，设置了两个信号量 one 的初始值为 0 ，two 的初始值为 1，然后在调用函数的时候，「读」的前提是 two 可以减一，如果不能减一就会阻塞在这里，一直等到「计算」操作完毕后，给 two 加一，然后就可以继续执行下一句输入。对于「计算」函数，也一样。</p><h1 id="三、多线程服务器"><a href="#三、多线程服务器" class="headerlink" title="三、多线程服务器"></a>三、多线程服务器</h1><p>下面是多个客户端之间可以交换信息的简单聊天程序：<br>服务端的chat_server.c的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CLNT 256</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">handle_clnt</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">send_msg</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg, <span class="hljs-type">int</span> len)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span>;<br><br><span class="hljs-type">int</span> clnt_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> clnt_socks[MAX_CLNT];<br><span class="hljs-type">pthread_mutex_t</span> mutx;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>    <span class="hljs-type">int</span> serv_sock, clnt_sock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_adr</span>, <span class="hljs-title">clnt_adr</span>;</span><br>    <span class="hljs-type">int</span> clnt_adr_sz;<br>    <span class="hljs-type">pthread_t</span> t_id;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    pthread_mutex_init(&amp;mutx, <span class="hljs-literal">NULL</span>);<br>    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 将socket文件描述符和本地的IP端口绑定到一起</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv_adr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv_adr));<br>    serv_adr.sin_family = AF_INET;<br>    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    serv_adr.sin_port = htons(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-keyword">if</span> (bind(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="hljs-keyword">sizeof</span>(serv_adr)) == <span class="hljs-number">-1</span>) &#123;<br>        error_handling(<span class="hljs-string">&quot;bind() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (listen(serv_sock, <span class="hljs-number">5</span>) == <span class="hljs-number">-1</span>)<br>        error_handling(<span class="hljs-string">&quot;listen() error&quot;</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        clnt_adr_sz = <span class="hljs-keyword">sizeof</span>(clnt_adr);<br>        clnt_sock = accept(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);<br><br>        pthread_mutex_lock(&amp;mutx); <span class="hljs-comment">// 上锁</span><br>        clnt_socks[clnt_cnt++] = clnt_sock; <span class="hljs-comment">// 写入新连接</span><br>        pthread_mutex_unlock(&amp;mutx); <span class="hljs-comment">// 解锁</span><br>        <br>        pthread_create(&amp;t_id, <span class="hljs-literal">NULL</span>, handle_clnt, (<span class="hljs-type">void</span> *)&amp;clnt_sock);       <span class="hljs-comment">//创建线程为新客户端服务，并且把clnt_sock作为参数传递</span><br>        pthread_detach(t_id);                                               <span class="hljs-comment">//引导线程销毁，不阻塞</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connected client IP: %s \n&quot;</span>, inet_ntoa(clnt_adr.sin_addr)); <span class="hljs-comment">//客户端连接的ip地址</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">handle_clnt</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">int</span> clnt_sock = *((<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-type">int</span> str_len = <span class="hljs-number">0</span>, i;<br>    <span class="hljs-type">char</span> msg[BUF_SIZE];<br>    <span class="hljs-comment">//接收到消息为0，代表当前客户端已经断开连接</span><br>    <span class="hljs-keyword">while</span> ((str_len = read(clnt_sock, msg, <span class="hljs-keyword">sizeof</span>(msg))) != <span class="hljs-number">0</span>)<br>        send_msg(msg, str_len);<br>    <br>    pthread_mutex_lock(&amp;mutx); <span class="hljs-comment">// 给临界区上锁</span><br>    <span class="hljs-comment">//删除没有连接的客户端</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; clnt_cnt; i++) &#123; <br>        <span class="hljs-keyword">if</span> (clnt_sock == clnt_socks[i]) &#123;<br>            <span class="hljs-keyword">while</span> (i++ &lt; clnt_cnt - <span class="hljs-number">1</span>) &#123;<br>                clnt_socks[i] = clnt_socks[i + <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    clnt_cnt--;<br>    pthread_mutex_unlock(&amp;mutx); <span class="hljs-comment">// 给临界区解锁</span><br>    close(clnt_sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_msg</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    pthread_mutex_lock(&amp;mutx);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; clnt_cnt; i++) &#123;<br>        write(clnt_socks[i], msg, len);<br>    &#125;<br>    pthread_mutex_unlock(&amp;mutx);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(msg, <span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端chat_clnt.c的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME_SIZE 20</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">send_msg</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">recv_msg</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span>;<br><br><span class="hljs-type">char</span> name[NAME_SIZE] = <span class="hljs-string">&quot;[DEFAULT]&quot;</span>;<br><span class="hljs-type">char</span> msg[BUF_SIZE];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>    <span class="hljs-type">int</span> sock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>;</span><br>    <span class="hljs-type">pthread_t</span> snd_thread, rcv_thread;<br>    <span class="hljs-type">void</span> *thread_return;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt; &lt;name&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">sprintf</span>(name, <span class="hljs-string">&quot;[%s]&quot;</span>, argv[<span class="hljs-number">3</span>]);<br>    sock = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="hljs-number">1</span>]);<br>    serv_addr.sin_port = htons(atoi(argv[<span class="hljs-number">2</span>]));<br><br>    <span class="hljs-keyword">if</span> (connect(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>) <br>        error_handling(<span class="hljs-string">&quot;connect() error&quot;</span>);<br><br>    pthread_create(&amp;snd_thread, <span class="hljs-literal">NULL</span>, send_msg, (<span class="hljs-type">void</span> *)&amp;sock);<span class="hljs-comment">//创建发送消息线程</span><br>    pthread_create(&amp;rcv_thread, <span class="hljs-literal">NULL</span>, recv_msg, (<span class="hljs-type">void</span> *)&amp;sock);<span class="hljs-comment">//创建接受消息线程</span><br><br>    pthread_join(snd_thread, &amp;thread_return);<br>    pthread_join(rcv_thread, &amp;thread_return);<br>    close(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">send_msg</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> <span class="hljs-comment">// 发送消息</span><br>&#123;<br>    <span class="hljs-type">int</span> sock = *((<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-type">char</span> name_msg[NAME_SIZE + BUF_SIZE];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        fgets(msg, BUF_SIZE, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(msg, <span class="hljs-string">&quot;q\n&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(msg, <span class="hljs-string">&quot;Q\n&quot;</span>))<br>        &#123;<br>            close(sock);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">sprintf</span>(name_msg, <span class="hljs-string">&quot;%s %s&quot;</span>, name, msg);<br>        write(sock, name_msg, <span class="hljs-built_in">strlen</span>(name_msg));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">recv_msg</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> <span class="hljs-comment">// 读取消息</span><br>&#123;<br>    <span class="hljs-type">int</span> sock = *((<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-type">char</span> name_msg[NAME_SIZE + BUF_SIZE];<br>    <span class="hljs-type">int</span> str_len;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        str_len = read(sock, name_msg, NAME_SIZE + BUF_SIZE - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (str_len == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>;<br>        name_msg[str_len] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">fputs</span>(name_msg, <span class="hljs-built_in">stdout</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(msg, <span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的服务端示例中，需要掌握临界区的构成，访问全局变量 clnt_cnt 和数组 clnt_socks 的代码将构成临界区，添加和删除客户端时，变量 clnt_cnt 和数组 clnt_socks 将同时发生变化。因此下列情形会导致数据不一致，从而引发错误：</p><ul><li><code>线程 A 从数组 clnt_socks 中删除套接字信息，同时线程 B 读取 clnt_cnt 变量</code></li><li><code>线程 A 读取变量 clnt_cnt ，同时线程 B 将套接字信息添加到 clnt_socks 数组</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈多线程</title>
    <link href="/2022/12/31/%E6%B5%85%E8%B0%88%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/12/31/%E6%B5%85%E8%B0%88%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、理解线程的概念"><a href="#一、理解线程的概念" class="headerlink" title="一、理解线程的概念"></a>一、理解线程的概念</h1><h2 id="1-引入线程的原因"><a href="#1-引入线程的原因" class="headerlink" title="1.引入线程的原因"></a>1.引入线程的原因</h2><p>在多进程服务端中，创建（复制）进程的工作本身会给操作系统带来相当沉重的负担。而且，每个进程都具有独立的内存空间，所以进程间通信的实现难度也会随之提高。换言之，多进程的缺点可概括为：</p><ul><li><code>创建进程的过程会带来一定的开销</code></li><li><code>为了完成进程间数据交换，需要特殊的 IPC 技术。</code><br> 但是更大的缺点是下面的：</li><li><code>每秒少则 10 次，多则千次的「上下文切换」是创建进程的最大开销</code><br> 只有一个 CPU 的系统是将时间分成多个微小的块后分配给了多个进程。为了分时使用 CPU ，需要「上下文切换」的过程。「上下文切换」是指运行程序前需要将相应进程信息读入内存，如果运行进程 A 后紧接着需要运行进程 B ，就应该将进程 A 相关信息移出内存，并读入进程 B 相关信息。这就是上下文切换。但是此时进程 A 的数据将被移动到硬盘，所以上下文切换要很长时间，即使通过优化加快速度，也会存在一定的局限。</li></ul><p>为了保持多进程的优点，同时在一定程度上克服其缺点，人们引入的线程（Thread）的概念。这是为了将进程的各种劣势降至最低程度（不是直接消除）而设立的一种「轻量级进程」。线程比进程具有如下优点：</p><ul><li><code>线程的创建和上下文切换比进程的创建和上下文切换更快</code></li><li><code>线程间交换数据无需特殊技术</code></li></ul><h2 id="2、线程和进程的差异"><a href="#2、线程和进程的差异" class="headerlink" title="2、线程和进程的差异"></a>2、线程和进程的差异</h2><p>线程是为了解决：为了得到多条代码执行流而复制整个内存区域的负担太重。</p><p>每个进程的内存空间都由保存全局变量的「数据区」、向 malloc 等函数动态分配提供空间的堆（Heap）、函数运行时间使用的栈（Stack）构成。每个进程都有独立的这种空间，多个进程的内存结构如图所示：<br><img src="/../assets/img/post1/fig1.png" alt="线程的内存结构"></p><p>但如果以获得多个代码执行流为目的，则不应该像上图那样完全分离内存结构，而只需分离栈区域。通过这种方式可以获得如下优势：</p><ul><li><code>上下文切换时不需要切换数据区和堆</code></li><li><code>可以利用数据区和堆交换数据</code></li></ul><p>实际上这就是线程。线程为了保持多条代码执行流而隔开了栈区域，因此具有如下图所示的内存结构：<br><img src="/../assets/img/post1/fig2.png" alt="线程的内存结构"><br>如图所示，多个线程共享数据区和堆。为了保持这种结构，线程将在进程内创建并运行。也就是说，进程和线程可以定义为如下形式：</p><ul><li><code>进程：在操作系统构成单独执行流的单位</code></li><li><code>线程：在进程构成单独执行流的单位</code><br>如果说进程在操作系统内部生成多个执行流，那么线程就在同一进程内部创建多条执行流。因此，操作系统、进程、线程之间的关系可以表示为下图：<br><img src="/../assets/img/post1/fig3.png" alt="操作系统、进程、线程之间的关系"></li></ul><h1 id="二、线程的创建及运行"><a href="#二、线程的创建及运行" class="headerlink" title="二、线程的创建及运行"></a>二、线程的创建及运行</h1><h2 id="1、线程的创建和执行流程"><a href="#1、线程的创建和执行流程" class="headerlink" title="1、线程的创建和执行流程"></a>1、线程的创建和执行流程</h2><p>在Linux中可使用以下API来创建线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *<span class="hljs-keyword">restrict</span> thread,</span><br><span class="hljs-params">                   <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *<span class="hljs-keyword">restrict</span> attr,</span><br><span class="hljs-params">                   <span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),</span><br><span class="hljs-params">                   <span class="hljs-type">void</span> *<span class="hljs-keyword">restrict</span> arg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">thread : 保存新创建线程 ID 的变量地址值。线程与进程相同，也需要用于区分不同线程的 ID</span><br><span class="hljs-comment">attr : 用于传递线程属性的参数，传递 NULL 时，创建默认属性的线程</span><br><span class="hljs-comment">start_routine : 相当于线程 main 函数的、在单独执行流中执行的函数地址值（函数指针）</span><br><span class="hljs-comment">arg : 通过第三个参数传递的调用函数时包含传递参数信息的变量地址值</span><br><span class="hljs-comment">    //传递参数变量的地址给start_routine函数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面通过简单示例了解该函数功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>    <span class="hljs-type">pthread_t</span> t_id;<br>    <span class="hljs-type">int</span> thread_param = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// 请求创建一个线程，从 thread_main 调用开始，在单独的执行流中运行。同时传递参数</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;t_id, <span class="hljs-literal">NULL</span>, thread_main, (<span class="hljs-type">void</span> *)&amp;thread_param) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pthread_create() error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">//延迟进程终止时间</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;end of main&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<span class="hljs-comment">//传入的参数是 pthread_create 的第四个</span><br><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> cnt = *((<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;runing thread&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc thread1.c -o tr1 -lpthread # 线程相关代码编译时需要添加 -lpthread 选项声明需要连接到线程库<br>./tr1<br></code></pre></td></tr></table></figure><p>上述程序的执行如图所示：<br><img src="/../assets/img/post1/fig4.png" alt="示例thread1.c的执行流程"><br>可以看出，程序在主进程没有结束时，生成的线程每隔一秒输出一次 running thread ，但是如果主进程没有等待十秒，而是直接结束，这样也会强制结束线程，不论线程有没有运行完毕。</p><p>那是否意味着主进程必须每次都 sleep 来等待线程执行完毕？并不需要，可以通过以下函数解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **status)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回 -1</span><br><span class="hljs-comment">thread : 该参数值 ID 的线程终止后才会从该函数返回</span><br><span class="hljs-comment">status : 保存线程的 main 函数返回值的指针变量地址值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>作用就是调用该函数的进程（或线程）将进入等待状态，知道第一个参数为 ID 的线程终止为止。而且可以得到线程的 main 函数的返回值。下面是该函数的用法代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>    <span class="hljs-type">pthread_t</span> t_id;<br>    <span class="hljs-type">int</span> thread_parm = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">void</span> *thr_ret;<br>    <span class="hljs-comment">// 请求创建一个线程，从 thread_main 调用开始，在单独的执行流中运行。同时传递参数</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;t_id, <span class="hljs-literal">NULL</span>, thread_main, (<span class="hljs-type">void</span> *)&amp;thread_parm) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pthread_create() error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>     <span class="hljs-comment">//main函数将等待 ID 保存在 t_id 变量中的线程终止</span><br>     <span class="hljs-keyword">if</span> (pthread_join(t_id, &amp;thr_ret) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pthread_join() error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>     &#125;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread return message : %s \n&quot;</span>, (<span class="hljs-type">char</span> *)thr_ret);<br>     <span class="hljs-built_in">free</span>(thr_ret);<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> <span class="hljs-comment">//传入的参数是 pthread_create 的第四个</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> cnt = *((<span class="hljs-type">int</span> *)arg);<br>    <span class="hljs-type">char</span> *msg = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">strcpy</span>(msg, <span class="hljs-string">&quot;Hello,I&#x27;am thread~ \n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>    &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;running thread&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)msg; <span class="hljs-comment">//返回值是 thread_main 函数中内部动态分配的内存空间地址值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面是该函数的执行流程图：<br><img src="/../assets/img/post1/fig5.png" alt="调用pthread_jion函数"><br>在线程库函数中为我们提供了线程分离函数 pthread_detach()，调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用 pthread_join() 就回收不到子线程资源了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> th)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回 0 ，失败时返回其他值</span><br><span class="hljs-comment">thread : 终止的同时需要销毁的线程 ID</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>面的代码中，在主线程中创建子线程，并调用线程分离函数，实现了主线程和子线程的分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">// 子线程的处理代码</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">working</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">9</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child == i: = %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1. 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, working, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);<br>    <span class="hljs-comment">// 2. 子线程不会执行下边的代码, 主线程执行</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置子线程和主线程分离</span><br>    pthread_detach(tid);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit!\n&quot;</span>);<br>    <span class="hljs-comment">// 让主线程自己退出即可</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、可在临界区内调用的函数"><a href="#2、可在临界区内调用的函数" class="headerlink" title="2、可在临界区内调用的函数"></a>2、可在临界区内调用的函数</h2><p>在同步的程序设计中，临界区块（Critical section）指的是一个访问共享资源（例如：共享设备或是共享存储器）的程序片段，而这些共享资源有无法同时被多个线程访问的特性。</p><p>当有线程进入临界区块时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区块的进入点与离开点实现，以确保这些共享资源是被异或的使用，例如：semaphore。</p><p>只能被单一线程访问的设备，例如：打印机。</p><p>一个最简单的实现方法就是当线程（Thread）进入临界区块时，禁止改变处理器；在uni-processor系统上，可以用“禁止中断（CLI）”来完成，避免发生系统调用（System Call）导致的上下文交换（Context switching）；当离开临界区块时，处理器恢复原先的状态。</p><p>根据临界区是否引起问题，函数可以分为以下 2 类：</p><ul><li>线程安全函数（Thread-safe function）</li><li>非线程安全函数（Thread-unsafe function）</li></ul><p>线程安全函数被多个线程同时调用也不会发生问题。反之，非线程安全函数被同时调用时会引发问题。但这并非有关于临界区的讨论，线程安全的函数中同样可能存在临界区。只是在线程安全的函数中，同时被多个线程调用时可通过一些措施避免问题。</p><p>幸运的是，大多数标准函数都是线程安全函数。操作系统在定义非线程安全函数的同时，提供了具有相同功能的线程安全的函数。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> hostent *<span class="hljs-title function_">gethostbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *hostname)</span>;<br></code></pre></td></tr></table></figure><p>同时，也提供了同一功能的安全函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> hostent *<span class="hljs-title function_">gethostbyname_r</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">                                <span class="hljs-keyword">struct</span> hostent *result,</span><br><span class="hljs-params">                                <span class="hljs-type">char</span> *buffer,</span><br><span class="hljs-params">                                <span class="hljs-type">int</span> intbuflen,</span><br><span class="hljs-params">                                <span class="hljs-type">int</span> *h_errnop)</span>;<br></code></pre></td></tr></table></figure><p>线程安全函数结尾通常是 _r 。但是使用线程安全函数会给程序员带来额外的负担，可以通过以下方法自动将 gethostbyname 函数调用改为 gethostbyname_r 函数调用。</p><blockquote><p>声明头文件前定义 _REENTRANT 宏。</p></blockquote><p>无需特意更改源代码加，可以在编译的时候指定编译参数定义宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -D_REENTRANT mythread.c -o mthread -lpthread<br></code></pre></td></tr></table></figure><h2 id="3、工作（Worker）线程模型"><a href="#3、工作（Worker）线程模型" class="headerlink" title="3、工作（Worker）线程模型"></a>3、工作（Worker）线程模型</h2><p>下面的示例是计算从 1 到 10 的和，但并不是通过 main 函数进行运算，而是创建两个线程，其中一个线程计算 1 到 5 的和，另一个线程计算 6 到 10 的和，main 函数只负责输出运算结果。这种方式的线程模型称为「工作线程」。显示该程序的执行流程图：<br><img src="/../assets/img/post1/fig6.png" alt="示例thread3.c执行流程"><br>下面是代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_summation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">char</span>* argv[])</span> &#123;<br><br>    <span class="hljs-type">pthread_t</span> id_t1, id_t2;<br>    <span class="hljs-type">int</span> range1[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> range2[] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">10</span>&#125;;<br><br>    pthread_create(&amp;id_t1, <span class="hljs-literal">NULL</span>, thread_summation, (<span class="hljs-type">void</span> *)range1);<br>    pthread_create(&amp;id_t2, <span class="hljs-literal">NULL</span>, thread_summation, (<span class="hljs-type">void</span> *)range2);<br><br>    pthread_join(id_t1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(id_t2, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %d\n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_summation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> start = ((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> end = ((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (start &lt;= end)<br>    &#123;<br>        sum += start;<br>        start++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO多路复用--epoll</title>
    <link href="/2022/12/29/epoll/"/>
    <url>/2022/12/29/epoll/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>IO 多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll 是 select 和 poll 的升级版，相较于这两个前辈，epoll 改进了工作方式，因此它更加高效。</p><p>epoll相对于select&#x2F;poll，有以下优点：</p><ul><li><code>对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的</code>。</li><li><code>select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降</code></li><li><code>select和poll工作过程中存在内核/用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。</code></li><li><code>程序猿需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测</code></li><li><code>使用 epoll 没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制</code></li></ul><h1 id="二、epoll的应用"><a href="#二、epoll的应用" class="headerlink" title="二、epoll的应用"></a>二、epoll的应用</h1><p>linux提供如下三个epoll函数，分别处理不同的操作，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><span class="hljs-comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br><span class="hljs-comment">// 检测epoll树中是否有就绪的文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br><br></code></pre></td></tr></table></figure><p><strong>epoll_create()</strong> 函数的作用是创建一个红黑树模型的实例，用于管理待检测的文件描述符的集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li>函数参数 size：在 Linux 内核 2.6.8 版本以后，这个参数是被忽略的，只需要指定一个大于 0 的数值就可以了。</li><li>函数返回值：<ul><li>失败：返回 - 1</li><li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的 epoll 实例了</li></ul></li></ul><p><strong>epoll_ctl()</strong> 函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 联合体, 多个变量共用同一块内存        </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span> &#123;</span><br> <span class="hljs-type">void</span>        *ptr;<br><span class="hljs-type">int</span>          fd;<span class="hljs-comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span><br><span class="hljs-type">uint32_t</span>     u32;<br><span class="hljs-type">uint64_t</span>     u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br><span class="hljs-type">uint32_t</span>     events;      <span class="hljs-comment">/* Epoll events */</span><br><span class="hljs-type">epoll_data_t</span> data;        <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br></code></pre></td></tr></table></figure><ul><li>函数参数<ul><li>epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例</li><li>op：这是一个枚举值，控制通过该函数执行什么操作<ul><li>EPOLL_CTL_ADD：往 epoll 模型中添加新的节点</li><li>EPOLL_CTL_MOD：修改 epoll 模型中已经存在的节点</li><li>EPOLL_CTL_DEL：删除 epoll 模型中的指定的节点</li></ul></li><li>fd：文件描述符，即要添加 &#x2F; 修改 &#x2F; 删除的文件描述符</li><li>event：epoll 事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件<ul><li>events：委托 epoll 检测的事件<ul><li>EPOLLIN：读事件，接收数据，检测读缓冲区，如果有数据该文件描述符就绪</li><li>EPOLLOUT：写事件，发送数据，检测写缓冲区，如果可写该文件描述符就绪</li><li>EPOLLERR：异常事件</li></ul></li><li>data：用户数据变量，这是一个联合体类型，通常情况下使用里边的 fd 成员，用于存储待检测的文件描述符的值，在调用 epoll_wait() 函数的时候这个值会被传出。</li></ul></li></ul></li><li>函数返回值：<ul><li>失败：返回 - 1</li><li>成功：返回 0</li></ul></li></ul><p><strong>epoll_wait()</strong> 函数的作用是检测创建的 epoll 实例中有没有就绪的文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br></code></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例</li><li>events：传出参数，这是一个结构体数组的地址，里边存储了已就绪的文件描述符的信息</li><li>maxevents：修饰第二个参数，结构体数组的容量（元素个数）</li><li>timeout：如果检测的 epoll 实例中没有已就绪的文件描述符，该函数阻塞的时长，单位 ms 毫秒<ul><li>0：函数不阻塞，不管 epoll 实例中有没有就绪的文件描述符，函数被调用后都直接返回</li><li>大于 0：如果 epoll 实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li><li>-1：函数一直阻塞，直到 epoll 实例中有已就绪的文件描述符之后才解除阻塞</li></ul></li></ul><p></p></li><li>函数返回值 ：<ul><li>成功：<ul><li>等于 0：函数是阻塞被强制解除了，没有检测到满足条件的文件描述符</li><li>大于 0：检测到的已就绪的文件描述符的总个数</li></ul></li><li>失败：返回 - 1</li></ul></li></ul><p>基于epoll的回声服务器代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_SIZE 50</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>    <span class="hljs-type">int</span> serv_sock, clnt_sock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_adr</span>, <span class="hljs-title">clnt_adr</span>;</span><br>    <span class="hljs-type">socklen_t</span> adr_sz;<br>    <span class="hljs-type">int</span> str_len, i;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> *<span class="hljs-title">ep_events</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span><br>    <span class="hljs-type">int</span> epfd, event_cnt;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">memset</span>(&amp;serv_adr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv_adr));<br>    serv_adr.sin_family = AF_INET;<br>    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    serv_adr.sin_port = htons(atoi(argv[<span class="hljs-number">1</span>]));<br><br>    <span class="hljs-keyword">if</span> (bind(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="hljs-keyword">sizeof</span>(serv_adr)) == <span class="hljs-number">-1</span>) &#123;<br>        error_handling(<span class="hljs-string">&quot;bind() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (listen(serv_sock, <span class="hljs-number">5</span>) == <span class="hljs-number">-1</span>) &#123;<br>        error_handling(<span class="hljs-string">&quot;listen() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个epoll例程,返回一个文件描述符</span><br>    epfd = epoll_create(EPOLL_SIZE);<br>    ep_events = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event) * EPOLL_SIZE);<br><br>    event.events = EPOLLIN;<br>    event.data.fd = serv_sock;<br>    <span class="hljs-comment">// 在epoll例程内部注册监视对象文件描述符</span><br>    epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (event_cnt == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;epoll_wait() error&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; event_cnt; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ep_events[i].data.fd == serv_sock) &#123;<br>                adr_sz = <span class="hljs-keyword">sizeof</span>(clnt_adr);<br>                clnt_sock = accept(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;adr_sz);<br>                event.events = EPOLLIN;<br>                event.data.fd = clnt_sock;<br>                epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected client: %d \n&quot;</span>, clnt_sock);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);<br>                <span class="hljs-keyword">if</span> (str_len == <span class="hljs-number">0</span>) &#123;<br>                    epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, <span class="hljs-literal">NULL</span>);<br>                    close(ep_events[i].data.fd);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;closed client: %d\n&quot;</span>, ep_events[i].data.fd);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    write(ep_events[i].data.fd, buf, str_len);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    close(serv_sock);<br>    close(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span> &#123;<br>    <span class="hljs-built_in">fputs</span>(message, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程</title>
    <link href="/2022/12/27/socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/12/27/socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、socket编程常用函数"><a href="#一、socket编程常用函数" class="headerlink" title="一、socket编程常用函数"></a>一、socket编程常用函数</h1><h2 id="1-socket函数"><a href="#1-socket函数" class="headerlink" title="1.socket函数"></a>1.socket函数</h2><p>该函数的作用是创建一个套接字，相当于安装一个电话机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br><span class="hljs-comment">//成功时返回文件描述符，失败时返回-1</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>domain参数</strong>：</p><ul><li><pre><code class="hljs">AF_INET, 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</code></pre></li><li>AF_INET6, 与上面类似，不过是来用IPv6的地址</li><li>AF_UNIX, 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</li></ul></li><li><p><strong>type参数</strong>：</p><ul><li>SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</li><li>SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</li><li>SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</li><li>SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</li></ul></li><li><p><strong>protocol参数</strong>：</p><ul><li>传0 表示使用默认协议。</li></ul></li></ul><h2 id="2-bind函数"><a href="#2-bind函数" class="headerlink" title="2.bind函数"></a>2.bind函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *myaddr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">//成功时返回0，失败时返回-1</span><br></code></pre></td></tr></table></figure><ul><li><strong>sockfd参数</strong>：<ul><li>socket文件描述符</li></ul></li><li><strong>myaddr参数</strong>：<ul><li>构造出IP地址加端口号</li></ul></li><li><strong>addrlen参数</strong>：<ul><li>sizeof(myaddr)长度</li></ul></li></ul><h2 id="3-listen函数"><a href="#3-listen函数" class="headerlink" title="3.listen函数"></a>3.listen函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><span class="hljs-comment">//成功时返回0，失败时返回-1</span><br></code></pre></td></tr></table></figure><ul><li><strong>sockfd参数</strong>：<ul><li>socket文件描述符</li></ul></li><li><strong>backlog参数</strong>：<ul><li>连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列</li></ul></li></ul><h2 id="4-accept-函数"><a href="#4-accept-函数" class="headerlink" title="4. accept 函数"></a>4. accept 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> *addrlen)</span>;<br><span class="hljs-comment">//成功时返回文件描述符，失败时返回-1</span><br></code></pre></td></tr></table></figure><ul><li><strong>sockfd参数</strong>：<ul><li>服务端套接字的文件描述符</li></ul></li><li><strong>addr参数</strong>：<ul><li>保存发起连接请求的客户端地址信息的变量地址值</li></ul></li><li><strong>addrlen参数</strong>：<ul><li>的第二个参数addr结构体的长度，但是存放有长度的变量地址。</li></ul></li></ul><h2 id="5-connect函数"><a href="#5-connect函数" class="headerlink" title="5.connect函数"></a>5.connect函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-keyword">struct</span> sockaddr *servaddr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回0，失败返回-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><strong>sock参数</strong>：<ul><li>客户端套接字文件描述符</li></ul></li><li><strong>servaddr参数</strong>：<ul><li>保存目标服务器端地址信息的变量地址值</li></ul></li><li><strong>addrlen参数</strong>：<ul><li>以字节为单位传递给第二个结构体参数 servaddr 的变量地址长度</li></ul></li></ul><h2 id="6-write函数"><a href="#6-write函数" class="headerlink" title="6.write函数"></a>6.write函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回写入的字节数 ，失败时返回 -1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><strong>fd参数</strong>：<ul><li>显示数据传输对象的文件描述符</li></ul></li><li><strong>buf参数</strong>：<ul><li>保存要传输数据的缓冲值地址</li></ul></li><li><strong>nbytes参数</strong>：<ul><li>要传输数据的字节数</li></ul></li></ul><h2 id="7-read函数"><a href="#7-read函数" class="headerlink" title="7.read函数"></a>7.read函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功时返回接收的字节数（但遇到文件结尾则返回0），失败时返回-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><strong>fd参数</strong>：<ul><li>显示数据接收对象的文件描述符</li></ul></li><li><strong>buf参数</strong>：<ul><li>要保存接收的数据的缓冲地址值。</li></ul></li><li><strong>nbytes参数</strong>：<ul><li>要接收数据的最大字节数</li></ul></li></ul><h1 id="二、echo服务器示例"><a href="#二、echo服务器示例" class="headerlink" title="二、echo服务器示例"></a>二、echo服务器示例</h1><h2 id="socket模型创建流程图"><a href="#socket模型创建流程图" class="headerlink" title="socket模型创建流程图"></a>socket模型创建流程图</h2><p>   <img src="/../assets/img/post3/img1.png" alt="socket模型创建过程"></p><h2 id="1、服务器端"><a href="#1、服务器端" class="headerlink" title="1、服务器端"></a>1、服务器端</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> <span class="hljs-comment">//fork,read,write等系统调用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFF_SIZE 1024</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <br><br>    <span class="hljs-keyword">if</span> (argc!=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 1. 创建监听套接字</span><br>    <span class="hljs-type">int</span> serv_sock = <span class="hljs-built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<span class="hljs-comment">// 协议族(IPV4,IPV6),套接字类型(面向连接,面向消息),协议信息(TCP,UDP)</span><br>    <span class="hljs-comment">// 2.将socket()返回值和本地的IP端口绑到一起</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>])); <span class="hljs-comment">// 端口号10000,转化为网络字节序,网络传输统一使用大端序</span><br>    <span class="hljs-comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span><br>    <span class="hljs-comment">// 这个宏可以代表任意一个IP地址</span><br>    addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(serv_sock, (<span class="hljs-keyword">struct</span> sokaddr*) &amp;addr, <span class="hljs-built_in">sizeof</span>(addr)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;bind() error&quot;</span>);<br><br>    <span class="hljs-comment">// 3.设置监听</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(serv_sock, <span class="hljs-number">5</span>) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;linsten() error&quot;</span>);<br>   <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> clnt_addr;<br>    <span class="hljs-type">socklen_t</span> clnt_addr_size = <span class="hljs-built_in">sizeof</span>(clnt_addr);<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 4. 阻塞并等等待客户端连接</span><br>        <span class="hljs-type">int</span> clnt_sock = <span class="hljs-built_in">accept</span>(serv_sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);<br>        <span class="hljs-keyword">if</span> (clnt_sock == <span class="hljs-number">-1</span>) <br>            <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;accpet() error&quot;</span>);<br><br>        <span class="hljs-comment">// 5.和客户端通信</span><br>        <span class="hljs-comment">// 接收数据</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> str_len;<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">while</span> ((str_len = <span class="hljs-built_in">read</span>(clnt_sock, buf, BUFF_SIZE)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">write</span>(clnt_sock, buf, str_len);<br>        <br>        <span class="hljs-built_in">close</span>(clnt_sock);<br>    &#125;<br>    <br>    <span class="hljs-built_in">close</span>(serv_sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span> </span>&#123;<br>    <span class="hljs-built_in">fputs</span>(message, stderr);<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;\n&quot;</span>, stderr);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> <span class="hljs-comment">//fork,read,write等系统调用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFF_SIZE 1024</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> sock;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    <span class="hljs-type">char</span> message[BUFF_SIZE];<br>    <span class="hljs-type">int</span> str_len;<br>    <span class="hljs-keyword">if</span> (argc!=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 1.创建客户端套接字</span><br>    sock = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;socket() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>); <span class="hljs-comment">// 将IP地址字符串转化为32位整数类型</span><br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-comment">// 2.向服务器端发送连接请求</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>) <br>        <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;connect() error&quot;</span>);<br>    <span class="hljs-comment">// 3. 与服务端通信</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入要发送的内容,按q退出:&quot;</span>);<br>        <span class="hljs-built_in">fgets</span>(buf, BUFF_SIZE, stdin);<br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;q&#x27;</span>) <span class="hljs-keyword">break</span>;<br>        str_len=<span class="hljs-built_in">write</span>(sock, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-type">int</span> recv_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (recv_len&lt;str_len) &#123;<br>            <span class="hljs-type">int</span> cnt_len = <span class="hljs-built_in">read</span>(sock, buf, BUFF_SIZE - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (cnt_len == <span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;read() error&quot;</span>);<br>            recv_len += cnt_len;<br>        &#125;<br>        <br>        buf[str_len]=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message form server:%s\n&quot;</span>, buf);<br>        <span class="hljs-built_in">close</span>(sock);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span> </span>&#123;<br>    <span class="hljs-built_in">fputs</span>(message, stderr);<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;\n&quot;</span>, stderr);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2022/08/10/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2022/08/10/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>智能指针是C++11引入的新特性,用于解决以下问题:</p><ul><li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li><li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li><li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li></ul><p>使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。</p><p>C++中的智能指针有4种，分别为：<strong>shared_ptr</strong>、<strong>unique_ptr</strong>、<strong>weak_ptr</strong>、<strong>auto_ptr</strong>，其中auto_ptr被C++11弃用。</p><h1 id="三种智能指针的区别"><a href="#三种智能指针的区别" class="headerlink" title="三种智能指针的区别"></a>三种智能指针的区别</h1><p><strong>shared_ptr和unique_ptr都支持的操作</strong><br><img src="/../assets/img/post4/img1.png"></p><h2 id="unique-ptr指针"><a href="#unique-ptr指针" class="headerlink" title="unique_ptr指针"></a>unique_ptr指针</h2><ul><li><p><strong>unique_ptr原理:</strong><br> unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。</p></li><li><p><strong>unique_ptr操作:</strong><br><img src="/../assets/img/post4/img2.png"><br><strong>以下为unique_ptr的基本使用示例</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">C</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C constructor\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">C</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C delete\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 测试unique_ptr自动释放内存资源</span><br>    <span class="hljs-function">unique_ptr&lt;C&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> C())</span></span>;<br>    C* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">C</span>(); <span class="hljs-comment">// 普通指针没有delete不能自动释放内存资源</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">pu1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;this is pu1&quot;</span>))</span></span>;<br>    unique_ptr&lt;string&gt; pu2 = <span class="hljs-built_in">move</span>(pu1); <span class="hljs-comment">//不能直接将unique_ptr赋值,必须要用move()转化为临时对象</span><br>    unique_ptr&lt;string&gt; pu3;<br>    pu3 = <span class="hljs-built_in">unique_ptr</span>&lt;string&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;this is pu3&quot;</span>));<br>    cout &lt;&lt; *pu2 &lt;&lt; endl;<br>    <span class="hljs-comment">//使用release释放当前unique_ptr指针对所指堆内存的所有权,并且返回一个指向该堆内存指针用reset将该指针赋给pu1</span><br>    pu1.<span class="hljs-built_in">reset</span>(pu3.<span class="hljs-built_in">release</span>()); <br>    cout &lt;&lt; *pu1 &lt;&lt; endl;<br>    <span class="hljs-built_in">fun2</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">this is pu1</span><br><span class="hljs-comment">this is pu3</span><br><span class="hljs-comment">C constructor</span><br><span class="hljs-comment">C constructor</span><br><span class="hljs-comment">C delete</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><p><strong>为 unique_ptr 自定义释放规则</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myDel</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;myDel\n&quot;</span>;<br>        <span class="hljs-keyword">delete</span>[] p;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//为 unique_ptr 自定义释放规则</span><br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[], myDel&gt; <span class="hljs-title">p_arr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>; <span class="hljs-comment">//使用可调用的类</span><br>    <span class="hljs-keyword">auto</span> myDel2 = [](<span class="hljs-type">int</span>* p) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;myDel2\n&quot;</span>;<br>        <span class="hljs-keyword">delete</span>[] p;<br>    &#125;;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[], <span class="hljs-title">decltype</span><span class="hljs-params">(myDel2)</span>&gt; <span class="hljs-title">p_arr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>], myDel2)</span></span>; <span class="hljs-comment">//使用lambda函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">myDel2</span><br><span class="hljs-comment">myDel</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="shared-ptr指针"><a href="#shared-ptr指针" class="headerlink" title="shared_ptr指针"></a>shared_ptr指针</h2><ul><li><strong>shared_ptr的原理</strong><br>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</li><li><strong>shared_ptr的操作</strong></li></ul><p><img src="/../assets/img/post4/img3.png"><br><strong>以下为shared_ptr使用示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    ~<span class="hljs-built_in">B</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B delete\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    ~<span class="hljs-built_in">C</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C delete\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">auto</span> pc3 = <span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br>    &#123;<br>        shared_ptr&lt;C&gt; pc1 = pc3; <span class="hljs-comment">//由于增加了一个新的指针使用pc3所指的内存资源,所以引用计数增加1</span><br>        shared_ptr&lt;B&gt; pc2 = <span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br>        cout &lt;&lt; pc3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>        cout &lt;&lt; pc2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 由于pc1离开其作用域后放弃对内存的“使用权”，引用计数减1</span><br>    cout &lt;&lt; pc3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该程序输出:</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">B delete</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">C delete</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h2 id="weak-ptr指针"><a href="#weak-ptr指针" class="headerlink" title="weak_ptr指针"></a>weak_ptr指针</h2><ul><li><p><strong>weak_ptr指针的原理</strong><br>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, <strong>它的构造和析构不会引起引用记数的增加或减少</strong>。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p></li><li><p><strong>weak_ptr的操作</strong><br><img src="/../assets/img/post4/img2.png"><br><strong>weak_ptr避免引用时死锁的示例</strong></p></li></ul><p>(1).shared_ptr相互引用时造成死锁的示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdarg&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;B&gt; pb_; <span class="hljs-comment">// weak_ptr指针的构造和析构不会引起引用计数的增加和减少</span><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A delete\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I am A!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;A&gt; pa_;<br>    ~<span class="hljs-built_in">B</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B delete\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>   <br>    pb-&gt;pa_ = pa;<br>    pa-&gt;pb_ = pb;<br>    <br>    <span class="hljs-comment">// pa和pb的引用计数为2,离开此作用域后减为1,所以内存不会被释放</span><br>    cout &lt;&lt; pa.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <br>    cout &lt;&lt; pb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出:</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>(2).将类中的指针类型改为weak_ptr后:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdarg&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    weak_ptr&lt;B&gt; pb_; <span class="hljs-comment">// weak_ptr指针的构造和析构不会引起引用计数的增加和减少</span><br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A delete\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;I am A!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    weak_ptr&lt;A&gt; pa_;<br>    ~<span class="hljs-built_in">B</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B delete\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>   <br>    pb-&gt;pa_ = pa;<br>    pa-&gt;pb_ = pb;<br>   <br>    cout &lt;&lt; pa.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; pb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">A delete</span><br><span class="hljs-comment">B delete</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p> <strong>注意</strong>：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb-&gt;print(); 英文pb是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p &#x3D; pa-&gt;pb_.lock(); p-&gt;print(); </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//pb-&gt;pa_-&gt;print(); 错误</span><br>shared_ptr&lt;A&gt; p = pb-&gt;pa_.<span class="hljs-built_in">lock</span>();<br>p-&gt;<span class="hljs-built_in">print</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++static关键字</title>
    <link href="/2022/07/23/Cpp-static/"/>
    <url>/2022/07/23/Cpp-static/</url>
    
    <content type="html"><![CDATA[<p>static关键字使用时具有以下含义：</p><ul><li><strong>静态变量</strong>: 函数中的变量，类中的变量</li><li><strong>静态类成员</strong>: 类对象和类中的函数</li></ul><h1 id="一、静态变量"><a href="#一、静态变量" class="headerlink" title="一、静态变量"></a>一、静态变量</h1><ol><li>函数中的静态变量</li></ol><p>当变量声明为static时，空间将在程序的生命周期内分配。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。这对于在C &#x2F; C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><p>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    count++;<br>    cout &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">while</span> (t--)<br>        <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>在上面的程序中变量count被声明为static。因此，它的值通过函数调用来传递。每次调用函数时，都不会对变量计数进行初始化。</p><ol start="2"><li>类中的静态成员</li></ol><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>.对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始,只能使用类外的类名和范围解析运算符显式初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-built_in">Apple</span>()<br>    &#123;<br>        i++;<br>    &#125;;<br>&#125;;<br><span class="hljs-type">int</span> Apple::i = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Apple obj1;<br>    cout &lt;&lt; obj1.i &lt;&lt; endl; <span class="hljs-comment">//输出2</span><br>    Apple obj2;<br>    <span class="hljs-comment">// obj1.i = 2; 错误</span><br>    <br>    cout &lt;&lt; obj2.i; <span class="hljs-comment">// 输出3</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、静态成员"><a href="#二、静态成员" class="headerlink" title="二、静态成员"></a>二、静态成员</h1><ol><li>类对象为静态</li></ol><p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p><p>考虑以下程序，其中对象是非静态的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Apple</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Constructor&quot;</span> &lt;&lt; endl;<br>    &#125;;<br>    ~<span class="hljs-built_in">Apple</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        Apple obj1;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;End of main&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出:</span><br><span class="hljs-comment">Constructor</span><br><span class="hljs-comment">Destructor</span><br><span class="hljs-comment">End of main</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>在上面的程序中，对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内。 如果我们将对象声明为静态，现在让我们看看输出的变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Apple</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Constructor&quot;</span> &lt;&lt; endl;<br>    &#125;;<br>    ~<span class="hljs-built_in">Apple</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">static</span> Apple obj1;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;End of main&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出:</span><br><span class="hljs-comment">Constructor</span><br><span class="hljs-comment">End of main</span><br><span class="hljs-comment">Destructor</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。</p><ol start="2"><li>类中的静态函数</li></ol><p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Apple</span>() &#123;<br>        <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-type">static</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        a++; <span class="hljs-comment">// 正确</span><br>        <span class="hljs-comment">// b++; 错误，b为非静态成员变量</span><br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Apple</span>() &#123;<br>        <br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> Apple::a = <span class="hljs-number">100</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Apple::<span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出: 101</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++const关键字</title>
    <link href="/2022/07/20/Cpp-const%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/07/20/Cpp-const%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="一、const的含义"><a href="#一、const的含义" class="headerlink" title="一、const的含义"></a>一、const的含义</h1><p>C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。</p><h1 id="二、const的作用"><a href="#二、const的作用" class="headerlink" title="二、const的作用"></a>二、const的作用</h1><ul><li>可用于代替 #define 定义常量，可以进行类型检查，并且节省空间，避免不必要的内存分配</li></ul><blockquote><p>const常量和 #define 宏定义常量的区别:</p><ul><li><p>编译器处理方式不同.define宏是在预处理阶段展开,const常量是编译运行阶段使用</p></li><li><p>类型和安全检查不同.define宏没有类型，不做任何类型检查，仅仅是展开,const常量有具体的类型，在编译阶段会执行类型检查</p></li><li><p>存储方式不同.define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配</p></li><li><p>const定义的常量在程序运行过程中只有一份拷贝,而 #define 定义的常量在内存中有若干个拷贝。因此const可以节省空间</p></li></ul></blockquote><ul><li>防止修改，起保护作用，增加程序健壮性.如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span></span>&#123;<br>    i++; <span class="hljs-comment">//错误,const常量不可修改</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="三、const对象默认为文件局部变量"><a href="#三、const对象默认为文件局部变量" class="headerlink" title="三、const对象默认为文件局部变量"></a>三、const对象默认为文件局部变量</h1><p>非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。(extern变量可以在其他文件被访问)</p><blockquote><p>如,未被未被const修饰的变量在不同文件的访问</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; i &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在extern_file1.cpp文件中访问file1文件中的变量i</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// extern_file1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">//在访问的变量前加上extern关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">//输出10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>被const修饰的变量在不同文件中的访问</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; <span class="hljs-comment">//如果要在其他文件中被访问,必须要加上extern</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; i &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在extern_file1.cpp文件中访问file1文件中的变量i</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// extern_file1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">//在访问的变量前加上extern关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">//输出10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、指针与const"><a href="#四、指针与const" class="headerlink" title="四、指针与const"></a>四、指针与const</h1><ol><li><p>指向常量的指针<br>指针所指对象的值不能被修改,但指针可以被修改,并且非const对象的地址可以赋给指向常量的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a;<br><span class="hljs-comment">//*p = 10; 错误</span><br>p = &amp;b; <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li><p>常指针<br>const指针必须进行初始化，且const指针的值不能修改,但const所指对象的值可以被修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;b; <span class="hljs-comment">//const在*右边</span><br>*p = <span class="hljs-number">100</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">//p = &amp;c; 错误</span><br>cout &lt;&lt; *p &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>指向常量的常指针</p></li></ol><p>指针的值不能被修改,且指针指向对象的值也不能被修改,且必修要进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;b;<br><span class="hljs-comment">//*p = 100;错误</span><br><span class="hljs-comment">//p = &amp;c; 错误</span><br></code></pre></td></tr></table></figure><h1 id="五、函数中使用const"><a href="#五、函数中使用const" class="headerlink" title="五、函数中使用const"></a>五、函数中使用const</h1><p>函数中使用const主要有以下两个作用</p><ol><li><p>使传入的参数指针所指内容不可变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringCopy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span></span>;<br></code></pre></td></tr></table></figure><p>其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</p></li><li><p>参数为引用时,增加效率的同时防止修改</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;a)</span></span>;<br></code></pre></td></tr></table></figure><p>将函数的参数设为引用传递,可以不需要产生临时对象,因此就没有临时对象的构造、复制、析构过程而提高效率.但是引用传递有可能改变传入的对象,因此加上const可以防止传入对象被修改.</p><p>如果是内部数据类型如void func(int x)就没有必要改写成void func(const int &amp;x),因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p><h1 id="六、类中使用const"><a href="#六、类中使用const" class="headerlink" title="六、类中使用const"></a>六、类中使用const</h1><ol><li><p>const成员变量<br>类中的const成员变量必须通过初始化列表进行初始化，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">sum</span>(i) &#123;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>const成员函数<br>const修饰类的成员函数,不能改变对象的成员变量，也不能调用类中任何非const成员函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">sum</span>(i) &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">//错误</span><br>        <span class="hljs-built_in">fun2</span>(); <span class="hljs-comment">//正确</span><br>        a += <span class="hljs-number">10</span>; <span class="hljs-comment">//错误</span><br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">fun2</span>();<br>        a = <span class="hljs-number">100</span>;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; a + <span class="hljs-number">100</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>const对象</p></li></ol><p>const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.<br>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">sum</span>(i) &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">100</span>;<br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">A <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    obj.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">//正确</span><br>    obj.<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// 错误</span><br>    obj1.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// 正确</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>将常量变量与static结合</li></ol><p>  将const成员变量声明为static类型,可以在类外初始化</p><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> A::b = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++虚函数与纯虚函数</title>
    <link href="/2022/07/18/Cpp%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <url>/2022/07/18/Cpp%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、多态性"><a href="#一、多态性" class="headerlink" title="一、多态性"></a>一、多态性</h1><p>多态就是在同一个类或继承体系结构的基类与派生类中，用同名函数来实现各种不同的功能。</p><p><strong>静态绑定又称静态联编</strong>，是指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起。</p><p><strong>动态绑定又称动态联编</strong>，是指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数，即在程序运行时才把调用函数名与具体函数绑定在一起。</p><p><strong>编译时多态性</strong>： —静态联编(连接)—-系统在编译时就决定如何实现某一动作,即对某一消息如何处理.静态联编具有执行速度快的优点.在C++中的编译时多态性是通过函数重载和运算符重载实现的。 </p><p><strong>运行时多态性</strong>： —动态联编(连接)—-系统在运行时动态实现某一动作,即对某一消息在运行过程实现其如何响应.动态联编为系统提供了灵活和高度问题抽象的优点,在C++中的运行时多态性是通过继承和虚函数实现的。</p><h1 id="二、虚函数"><a href="#二、虚函数" class="headerlink" title="二、虚函数"></a>二、虚函数</h1><p><strong>虚函数的意义</strong></p><p>派生类对象可以赋值给基类对象， 派生类对象的地址可以赋值给指向基类对象的指针， 派生类对象可以作为基类对象的引用。</p><p>赋值相容的问题： 不论哪种赋值方式，都只能通过基类对象（或基类对象的指针或引用）访问到派生类对象从基类中继承到的成员， 不能借此访问派生类定义的成员。</p><p>虚函数使得可以通过基类对象的指针或引用访问派生类定义的成员。Virtual关键字其实质是告知编译系统，被指定为virtual的函数采用动态联编的形式编译。</p><p>如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myfun</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;my Base class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class fun&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myfun</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;my Derived class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base* p = <span class="hljs-keyword">new</span> Derived; <span class="hljs-comment">// 可以将派生类地址赋给基类指针，但不能将基类地址赋给派生类指针</span><br><br>    p-&gt;<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// 输出&quot;Derived class fun&quot;, fun为虚函数，因此调用的是派生类重新定义的fun函数</span><br>    p-&gt;<span class="hljs-built_in">myfun</span>(); <span class="hljs-comment">// 输出&quot;my Base class&quot;, myfun不是虚函数,因此调用的是基类的fun函数</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虚函数的特征</strong>:</p><ul><li>基类指针指向派生类的对象时，通过该指针访问其虚函数将调用派生类的版本。</li><li>一旦将某个成员函数声明为虚函数后，它在继承体系中就永远为虚函数了</li><li>如果基类定义了虚函数，当通过基类指针或引用调用派生类对象时，将访问到它们实际所指对象中的虚函数版本。</li><li>只有通过基类对象的指针和引用访问派生类对象的虚函数时，才能体现虚函数的特性。</li><li>派生类中的虚函数要保持其虚特征，必须与基类虚函数的函数原型完全相同，否则就是普通的重载函数，与基类的虚函数无关。</li><li>派生类通过从基类继承的成员函数调用虚函数时，将访问到派生类中的版本。</li><li>只有类的非静态成员函数才能被定义为虚函数，类的构造函数和静态成员函数不能定义为虚函数。原因是虚函数在继承层次结构中才能够发生作用，而构造函数、静态成员是不能够被继承的。</li><li>内联函数也不能是虚函数。因为内联函数采用的是静态联编的方式，而虚函数是在程序运行时才与具体函数动态绑定的，采用的是动态联编的方式，即使虚函数在类体内被定义，C++编译器也将它视为非内联函数。</li><li>基类析构函数几乎总是为虚析构函数。 why? 假定使用delete和一个指向派生类的基类指针来销毁派生类对象，如果基类析构函数不为虚,就如一个普通成员函数，delete函数调用的就是基类析构函数。在通过基类对象的引用或指针调用派生类对象时，将致使对象析构不彻底！</li></ul><h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><p>仅定义函数原型而不定义其实现的虚函数就是纯虚函数</p><p>纯虚函数的定义方式如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;<br><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>包含一个或多个纯虚函数的类就是抽象类,不能实例化抽象类,但是可以定义抽象类的指针和引用,定义一个抽象类的派生类,定义所有纯虚函数</p><p><strong>C++对抽象类具有以下限定</strong>:</p><ul><li>抽象类中含有纯虚函数，由于纯虚函数没有实现代码，所以不能建立抽象类的对象。</li><li>抽象类只能作为其他类的基类，可以通过抽象类对象的指针或引用访问到它的派生类对象，实现运行时的多态性。</li><li>如果派生类只是简单地继承了抽象类的纯虚函数，而没有重新定义基类的纯虚函数，则派生类也是一个抽象类。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++右值引用</title>
    <link href="/2022/07/17/C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2022/07/17/C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="左值和右值的区别"><a href="#左值和右值的区别" class="headerlink" title="左值和右值的区别"></a>左值和右值的区别</h1><p><strong>左值</strong>:存储在内存中、有明确存储地址（可寻址）的数据</p><p><strong>右值</strong>:没有明确存储地址（不可寻址）的值</p><p>区分左值和右值的方法:</p><ol><li><p>可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</p></li><li><p>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</p></li><li><p>返回类型为非引用的函数调用为右值</p></li><li><p>算术表达式为右值</p></li></ol><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>顾名思义,右值引用就是操纵右值的引用,如下左值引用和右值引用经典示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = num; <span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int &amp;&amp; a = num;  //错误,右值引用不能初始化为左值</span><br><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</p><p>右值引用可以对右值进行修改,例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<br>cout &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; a = <span class="hljs-number">10</span>; <span class="hljs-comment">//c++也可以定义常右值引用,但无实际用途</span><br></code></pre></td></tr></table></figure><p><strong>右值引用的作用</strong>:如下程序,通过使用move函数将左值转化为右值,然后调用移动构造函数,直接占用临时对象的空间,可以不用开辟新的空间,起到节省空间的作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">0</span>) :<span class="hljs-built_in">size</span>(size), <span class="hljs-built_in">name</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>            name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                name[i] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 深拷贝,将形参的所有内容复制一遍</span><br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> Student&amp; stu) &#123;<br>        size = stu.size;<br>        name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            name[i] = stu.name[i];<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 移动构造,直接把别人的东西占为己有</span><br>    <span class="hljs-built_in">Student</span>(Student&amp;&amp; stu) &#123;<br>        size = stu.size;<br>        name = stu.name;<br>        stu.name = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// stu为右值,使用后即将要消亡,所以要将指针赋为空</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;move constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Student</span>() &#123;<br>        <span class="hljs-keyword">delete</span> name;<br>        cout &lt;&lt; <span class="hljs-string">&quot;delect&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;Student&gt; school;<br>    <span class="hljs-function">Student <span class="hljs-title">stu</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-comment">// 使用move将左值转化为右值,调用移动构造函数</span><br>    school.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">move</span>(stu));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF915C Permute Digits（搜索+剪枝）</title>
    <link href="/2022/07/17/CF915C/"/>
    <url>/2022/07/17/CF915C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/problemset/problem/915/C">题目链接</a></p><h1 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h1><p>给出两个正整数a,b。在十进制下重排a，构造一个不超过b的最大数，不能有前导零。允许不去重排a。</p><p><strong>输入格式</strong>：</p><p>第一行一个数a(1&lt;&#x3D;a&lt;&#x3D;10^18^),第二行一个数b(1&lt;&#x3D;b&lt;&#x3D;10^18^)<br>数没有前导零，数据保证有解。</p><p><strong>输出格式</strong>：</p><p>输出一个数，表示a重排后不超过b的最大数，不应该有前导零。<br>输出的数的长度应该与a相等，它应该是a的一个排列。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h1><p>以字符串的形式输入,先将a字符串从小到大排序,然后dfs搜索来找到不超过b的最大数,需要经过剪枝优化来降低复杂度</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SE_IT set<span class="hljs-string">&lt;node&gt;</span>::iterator</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bug(a) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bugg(a,b) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> buggg(a,b,c) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> esp=<span class="hljs-number">1e-5</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br>string s1,s2,ans;<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">bool</span> flag;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string x,<span class="hljs-type">int</span> y,<span class="hljs-type">bool</span> flag)</span></span>&#123;<br>    <span class="hljs-comment">//bug(x)</span><br>    <span class="hljs-keyword">if</span>(x.<span class="hljs-built_in">size</span>()==s1.<span class="hljs-built_in">size</span>())&#123;<br>        ans=x;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>            <span class="hljs-keyword">if</span>(!flag&amp;&amp;s1[i]&gt;s2[y]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!flag&amp;&amp;s1[i]==s2[y])&#123;<br>                string st=<span class="hljs-string">&quot;&quot;</span>,st2;<br>                st2=s2.<span class="hljs-built_in">substr</span>(y,s2.<span class="hljs-built_in">size</span>()-y);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">size</span>();i++)<br>                    <span class="hljs-keyword">if</span>(!vis[i])<br>                        st+=s1[i];<br>                <span class="hljs-built_in">sort</span>(st.<span class="hljs-built_in">begin</span>(),st.<span class="hljs-built_in">end</span>());<br>                <span class="hljs-keyword">if</span>(st&gt;st2) <span class="hljs-keyword">return</span> ;<br>                <span class="hljs-keyword">if</span>(st==st2)&#123;<br>                    ans=x+st;<br>                    <span class="hljs-keyword">return</span> ;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(s1[i]&lt;s2[y])<br>                flag=<span class="hljs-number">1</span>;<br>            vis[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(x+s1[i],y+<span class="hljs-number">1</span>,flag);<br>            vis[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;s1&gt;&gt;s2;<br>    <span class="hljs-built_in">sort</span>(s1.<span class="hljs-built_in">begin</span>(),s1.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">char</span>&gt;());<br>    <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&lt;s2.<span class="hljs-built_in">size</span>())&#123;<br>        ans=s1;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2000000000001</span><br><span class="hljs-comment">2000000000000</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing4313. 满二叉树等长路径(递归+贪心）</title>
    <link href="/2022/07/17/AcWing4313/"/>
    <url>/2022/07/17/AcWing4313/</url>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.acwing.com/problem/content/4316/">题目链接</a></h1><p><strong>思路</strong><br><img src="https://img-blog.csdnimg.cn/d0e6b82da8424c91b9c02d74a12b2d73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASFozNTU3Mg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>若要使所有叶子节点到根节点距离相等,那么首先应使左子树的所有叶子节点到左子树根节点距离相等(设为l),使右子树所有叶子节点到右子树根节点距离相等(设为r),然后再将左右子树的所有叶子节点到根节点的距离变为 max(l,r),所以应增加的距离应为 |l-r|, 可利用递归对每一层实现这个过程</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; P;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> esp=<span class="hljs-number">1e-5</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-type">int</span> n,a[N],ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;=(<span class="hljs-number">1</span>&lt;&lt;n))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l=<span class="hljs-built_in">dfs</span>(x*<span class="hljs-number">2</span>)+a[x*<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> r=<span class="hljs-built_in">dfs</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)+a[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>    ans+=<span class="hljs-built_in">abs</span>(l-r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=(<span class="hljs-number">1</span>&lt;&lt;n+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>;i++)<br>        cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集+最小生成树（Kruskal算法）</title>
    <link href="/2022/07/16/Kruskal/"/>
    <url>/2022/07/16/Kruskal/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集常用于解决一些元素分组问题,管理一系列不相交的集合,主要操作如下:<br><strong>初始化</strong><br>将所有节点的祖先初始化为其本身:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化祖先节点,par[i]为i点的父节点,n为节点数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        par[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>查询</strong><br>查找祖先节点并且状态压缩,减小复杂度:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seek</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(par[i]==i)<span class="hljs-comment">//若i点的父节点为它本身时,则i点为祖先节点</span><br>        <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">return</span> par[i]=<span class="hljs-built_in">seek</span>(par[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>合并</strong><br>将两棵树合并,只需将其中一颗树的祖先节点改变为为另一棵树的祖先节点即可:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//合并节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-built_in">seek</span>(x),b=<span class="hljs-built_in">seek</span>(y);<br>    par[a]=b;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图两棵树合并前:<br><img src="https://img-blog.csdnimg.cn/20210601210027979.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjk5NDM2,size_16,color_FFFFFF,t_70#pic_center" alt="1"><br>两棵树合并后,右边的树祖先也变为了1:<br><img src="https://img-blog.csdnimg.cn/20210601210139367.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjk5NDM2,size_16,color_FFFFFF,t_70#pic_center" alt="2"></p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>该算法是运用并查集来求最小(或最大)生成树,主要步骤如下:<br>1.根据边权值大小将图中的每条边排序;<br>2.初始化并查集;<br>3.设图的顶点点数为n,从排序后的第一条边开始依次遍历n-1条边,将这n-1条边的权值求和,结果就为这张图的最小生成树;</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123; <span class="hljs-type">int</span> u,v,cost&#125;;<span class="hljs-comment">//边的起点、终点、权值</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> edge&amp; e1,<span class="hljs-type">const</span> edge&amp; e2)</span></span>&#123;<br><span class="hljs-keyword">return</span> e1.cost&lt;e2.cost;<br>&#125;<br><br>edge es[MAXN];<br><span class="hljs-type">int</span> V,E; <span class="hljs-comment">//顶点数和边数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">sort</span>(es,es+E,cmp); <span class="hljs-comment">//按照边的权值排序</span><br><span class="hljs-built_in">init</span>(); <span class="hljs-comment">//并查集的初始化</span><br><span class="hljs-type">int</span> mst=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;E;i++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">seek</span>(es[i].u)!=<span class="hljs-built_in">seek</span>(es[i].v))&#123;<br>            <span class="hljs-built_in">join</span>(es[i].u,es[i].v);<br>            mst+=es[i].cost;<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k==V<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//生成树的边数最多不超过V-1</span><br>&#125;<br><span class="hljs-keyword">return</span> mst;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路--Dijkstra算法+堆优化</title>
    <link href="/2022/07/16/Dijkstra/"/>
    <url>/2022/07/16/Dijkstra/</url>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra算法介绍"><a href="#Dijkstra算法介绍" class="headerlink" title="Dijkstra算法介绍"></a>Dijkstra算法介绍</h2><p><img src="https://img-blog.csdnimg.cn/20210623111311287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNjk5NDM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(1)算法原理:从源点开始,更新每个与源点相连的点的最短距离d[i].然后每次以d[i]最小的顶点为中心,继续更新与该顶点相连的顶点的d[i],此时该点的最短距离已确定,后面不再关心该顶点.<br>如上图,顶点1为源点,把d[1]设为0,先从点1开始,更新d[2]为2,d[3]为5,除去 d[1],由于d[2]最小,因此顶点2最短距离已确定,然后从顶点2开始更新d[i]大于d[2]的顶点的最短距离,依次类推.<br>(2)时间复杂度:非优化版本为O(|V|^2^),堆优化版本为O(|V||E|)</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p> <strong>1.非优化版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m,a,b,dn,s,t;<br><span class="hljs-type">int</span> dis[N];<span class="hljs-comment">//每个顶点到源点的最短距离</span><br><span class="hljs-type">int</span> w[N][N];<span class="hljs-comment">//每两个顶点之间边的权值</span><br><span class="hljs-comment">//初始化边权</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;<br>               w[i][j]=inf;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-type">bool</span> book[N]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">fill</span>(dis,dis+<span class="hljs-number">1</span>+n,inf);<br>    dis[s]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-type">int</span> v=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;<br>            <span class="hljs-comment">//找到离源点最近的顶点</span><br>            <span class="hljs-keyword">if</span>((v==<span class="hljs-number">-1</span>||dis[j]&lt;dis[v])&amp;&amp;!book[j])&#123;<br>                v=j;<br>            &#125;<br>        &#125;<br><br>        book[v]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>            dis[i]=<span class="hljs-built_in">min</span>(dis[i],dis[v]+w[v][i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!=<span class="hljs-number">0</span>&amp;&amp;m!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-comment">//输入边权</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>            cin&gt;&gt;a&gt;&gt;b&gt;&gt;dn;<br>            w[a][b]=w[b][a]=dn;<br>        &#125;<br>        cin&gt;&gt;s&gt;&gt;t;<br>        <span class="hljs-built_in">dijkstra</span>(s);<br>        cout&lt;&lt;dis[t]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.堆优化版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 2147483647</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; P;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> to,cost;<br>&#125;;<br><span class="hljs-type">int</span> n,m,sx,a,b,w;<br><span class="hljs-type">int</span> d[N];<br>vector&lt;edge&gt; G[N];<span class="hljs-comment">//邻接矩阵存储图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(d+<span class="hljs-number">1</span>,d+<span class="hljs-number">1</span>+n,inf);<br>    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;<br>    d[s]=<span class="hljs-number">0</span>;<br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(<span class="hljs-number">0</span>,s));<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        P q=que.<span class="hljs-built_in">top</span>();que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> v=q.second;<br>        <span class="hljs-comment">//P(d[e.to],e.to)可能多次进入队列了,因此要跳过q.first大的情况</span><br>        <span class="hljs-keyword">if</span>(d[v]&lt;q.first) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G[v].<span class="hljs-built_in">size</span>();i++)&#123;<br>            edge e=G[v][i];<br>            <span class="hljs-keyword">if</span>(d[v]+e.cost&lt;d[e.to])&#123;<br>                d[e.to]=d[v]+e.cost;<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(d[e.to],e.to));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P4779">1.P4779 【模板】单源最短路径（标准版）</a><br><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 2147483647</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; P;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> to,cost;<br>&#125;;<br><span class="hljs-type">int</span> n,m,sx,a,b,w;<br><span class="hljs-type">int</span> d[N];<br>vector&lt;edge&gt; G[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(d+<span class="hljs-number">1</span>,d+<span class="hljs-number">1</span>+n,inf);<br>    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;<br>    d[s]=<span class="hljs-number">0</span>;<br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(<span class="hljs-number">0</span>,s));<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        P q=que.<span class="hljs-built_in">top</span>();que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> v=q.second;<br>        <span class="hljs-keyword">if</span>(d[v]&lt;q.first) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G[v].<span class="hljs-built_in">size</span>();i++)&#123;<br>            edge e=G[v][i];<br>            <span class="hljs-keyword">if</span>(d[v]+e.cost&lt;d[e.to])&#123;<br>                d[e.to]=d[v]+e.cost;<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(d[e.to],e.to));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;sx;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        edge e;<br>        cin&gt;&gt;a&gt;&gt;e.to&gt;&gt;e.cost;<br>        G[a].<span class="hljs-built_in">push_back</span>(e);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(sx);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)<br>            cout&lt;&lt;d[i];<br>        <span class="hljs-keyword">else</span><br>            cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;d[i];<br>    &#125;<br>    cout&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1629">2.P1629 邮递员送信</a><br><em>此题需反向建图</em><br><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; P;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123; <span class="hljs-type">int</span> to,cost; &#125;;<br><span class="hljs-type">int</span> n,m,u,d[N&lt;&lt;<span class="hljs-number">1</span>];<br>vector&lt;edge&gt; G[N&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">fill</span>(d,d+n*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,inf);<br>    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;<br>    d[s]=<span class="hljs-number">0</span>;<br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(<span class="hljs-number">0</span>,s));<br><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>        P q=que.<span class="hljs-built_in">top</span>();que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> w=q.first,v=q.second;<br>        <span class="hljs-keyword">if</span>(d[v]&lt;q.first) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G[v].<span class="hljs-built_in">size</span>();i++)&#123;<br>            edge e=G[v][i];<br>            <span class="hljs-keyword">if</span>(d[v]+e.cost&lt;d[e.to])&#123;<br>                d[e.to]=d[v]+e.cost;<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">P</span>(d[e.to],e.to));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        edge e;<br>        cin&gt;&gt;u&gt;&gt;e.to&gt;&gt;e.cost;<br>        G[u].<span class="hljs-built_in">push_back</span>(e);<br>        edge e2;<br>        e2.to=u+n,e2.cost=e.cost;<br>        G[e.to+n].<span class="hljs-built_in">push_back</span>(e2);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        ans+=d[i];<br>    &#125;<br><br>    <span class="hljs-built_in">dijkstra</span>(n+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        ans+=d[n+i];<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序表实现归并排序</title>
    <link href="/2022/07/15/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/07/15/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>思路</strong>：分治思想，将线性表不断对半拆分，拆到只剩一个元素时就进行从小到大归并，递归实现<br><strong>代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE     0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK        1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR     0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -1</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE  200 <span class="hljs-comment">//线性表存储空间的初始分配量 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LISTINCREMENT   20 <span class="hljs-comment">//线性表存储空间的分配增量 </span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType *elem;<span class="hljs-comment">//存储空间基址</span><br><span class="hljs-type">int</span> length;<span class="hljs-comment">//当前长度</span><br><span class="hljs-type">int</span> listsize;<span class="hljs-comment">//当前分配的存储容量</span><br>&#125;SqList;<br><br><span class="hljs-function">Status <span class="hljs-title">InitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br><span class="hljs-comment">//构造一个空的线性表L</span><br>L.elem=(ElemType*)<span class="hljs-built_in">malloc</span>(LIST_INIT_SIZE*<span class="hljs-built_in">sizeof</span>(ElemType));<br><span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<span class="hljs-comment">//存储分配失败</span><br>L.length=<span class="hljs-number">0</span>;<span class="hljs-comment">//空表长度为0</span><br>L.listsize=LIST_INIT_SIZE;<span class="hljs-comment">//初始存储容量</span><br><span class="hljs-keyword">return</span> OK; <br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">ListInsert_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br><span class="hljs-comment">//在顺序表L中第i个位置之前插入新的元素e</span><br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.listsize+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  ERROR; <span class="hljs-comment">//i值不合法</span><br><span class="hljs-keyword">if</span>(L.length&gt;=L.listsize)&#123;<span class="hljs-comment">//当前存储空间已满,增加分配</span><br>ElemType *newbase=(ElemType*)<span class="hljs-built_in">realloc</span>(L.elem,(L.listsize+LISTINCREMENT)*<span class="hljs-built_in">sizeof</span>(ElemType));<br><span class="hljs-keyword">if</span>(!newbase) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>L.elem=newbase;<span class="hljs-comment">//新基址 </span><br>L.listsize+=LISTINCREMENT;<span class="hljs-comment">//增加存储容量 </span><br>&#125;<br>ElemType *q=&amp;(L.elem[i<span class="hljs-number">-1</span>]),*p;<br><span class="hljs-keyword">for</span>(p=&amp;(L.elem[L.length<span class="hljs-number">-1</span>]);p&gt;=q;--p) *(p+<span class="hljs-number">1</span>)=*p;<br>*q=e;<br>++L.length;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<span class="hljs-comment">//ListInsert_Sq</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_Sq</span><span class="hljs-params">(SqList La,SqList Lb,SqList &amp;Lc)</span></span>&#123;<br><span class="hljs-comment">//已知顺序线性表La和Lb的元素按值非递减排列</span><br><span class="hljs-comment">//归并La和Lb得到新的顺序线性表Lc,Lc的元素也按值非递减排列</span><br>ElemType *pa,*pb,*pc,*pa_last,*pb_last;<br>pa=La.elem;pb=Lb.elem;<br>Lc.listsize=Lc.length=La.length+Lb.length;<br>pc=Lc.elem=(ElemType*)<span class="hljs-built_in">malloc</span>(Lc.listsize*<span class="hljs-built_in">sizeof</span>(ElemType));<br><span class="hljs-keyword">if</span>(!Lc.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>pa_last=La.elem+La.length<span class="hljs-number">-1</span>;<br>pb_last=Lb.elem+Lb.length<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(pa&lt;=pa_last&amp;&amp;pb&lt;=pb_last)&#123;<br><span class="hljs-keyword">if</span>(*pa&lt;=*pb) *pc++=*pa++;<br><span class="hljs-keyword">else</span> *pc++=*pb++;<br>&#125;<br><span class="hljs-keyword">while</span>(pa&lt;=pa_last)*pc++=*pa++;<br><span class="hljs-keyword">while</span>(pb&lt;=pb_last)*pc++=*pb++;<br>&#125;<span class="hljs-comment">//MergeList_Sq</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList_Sq</span><span class="hljs-params">(SqList L)</span></span>&#123;<br><span class="hljs-comment">//输出线性表L中的元素 </span><br>ElemType *p;<br><span class="hljs-keyword">for</span>(p=L.elem;p&lt;L.elem+L.length;++p)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<span class="hljs-comment">//PrintList_Sq</span><br><br><span class="hljs-function">Status <span class="hljs-title">DivList</span><span class="hljs-params">(SqList L,SqList &amp;La,SqList &amp;Lb)</span></span>&#123;<br><span class="hljs-comment">//将线性表L对半分解成两个线性表 </span><br><span class="hljs-keyword">if</span>(L.length&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR;<br>ElemType *p,*pa,*pb;<br>La.listsize=La.length=L.length/<span class="hljs-number">2</span>;<br>Lb.listsize=Lb.length=L.length-La.length;<br>pa=La.elem=(ElemType*)<span class="hljs-built_in">malloc</span>(La.listsize*<span class="hljs-built_in">sizeof</span>(ElemType));<br>pb=Lb.elem=(ElemType*)<span class="hljs-built_in">malloc</span>(Lb.listsize*<span class="hljs-built_in">sizeof</span>(ElemType));<br><span class="hljs-keyword">for</span>(p=L.elem;p&lt;=&amp;(L.elem[La.length<span class="hljs-number">-1</span>]);)<br>*pa++=*p++;<br><span class="hljs-keyword">while</span>(p&lt;=&amp;(L.elem[L.length<span class="hljs-number">-1</span>])) *pb++=*p++;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge_Sort</span><span class="hljs-params">(SqList L,SqList &amp;Ls)</span></span>&#123;<br><span class="hljs-comment">//归并排序,排序后的线性表为Ls</span><br><span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//当线性表被拆到只有一个元素时,结束递归 </span><br>Ls=L;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>SqList La,Lb,Lc,Ld;<br><span class="hljs-built_in">DivList</span>(L,La,Lb);<span class="hljs-comment">//将线性表L拆分成La和Lb </span><br><span class="hljs-built_in">Merge_Sort</span>(La,Lc);<br><span class="hljs-built_in">Merge_Sort</span>(Lb,Ld);<br><span class="hljs-built_in">MergeList_Sq</span>(Lc,Ld,Ls);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>SqList L,La,Lb,Ls;<br><span class="hljs-built_in">InitList_Sq</span>(L);<br><br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>a=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">200</span>;<span class="hljs-comment">//产生0到199之间的随机数进行测试 </span><br><span class="hljs-built_in">ListInsert_Sq</span>(L,i,a);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始序列:\n&quot;</span>);<br><span class="hljs-built_in">PrintList_Sq</span>(L);<br><span class="hljs-built_in">Merge_Sort</span>(L,Ls);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;排序后的序列:\n&quot;</span>);<br><span class="hljs-built_in">PrintList_Sq</span>(Ls);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Acwing4310.树的DFS(dfs序列)</title>
    <link href="/2022/07/15/Acwing4310-%E6%A0%91%E7%9A%84DFS/"/>
    <url>/2022/07/15/Acwing4310-%E6%A0%91%E7%9A%84DFS/</url>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.acwing.com/problem/content/4313/">题目链接</a></h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用dfs跑一遍整棵树,分别用一个数组记录好每个结点的dfs序(dfn数组),整棵树的dfs序列(p数组),以每个不同节点为根节点的子树节点数量(sz数组).<br>若询问时输入u,k,当k&gt;sz[u]时无解,否则答案为p[dfn[u]+k-1].</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bug(a) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bugg(a,b) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> buggg(a,b,c) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; P;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-type">int</span> n,q;<br><span class="hljs-type">int</span> dfn[N],p[N],top,sz[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; g[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    dfn[u]=top,p[top]=u;<br>    top++;<br>    sz[u]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:g[u])&#123;<br>        <span class="hljs-built_in">dfs</span>(v);<br>        sz[u]+=sz[v];<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>        g[t].<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//for(int i=1;i&lt;=n;i++) sort(g[i].begin(),g[i].end());</span><br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> u,k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;k);<br>        <span class="hljs-keyword">if</span>(k&gt;sz[u])<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,p[dfn[u]+k<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组总结</title>
    <link href="/2022/07/15/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/15/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、树状数组介绍"><a href="#一、树状数组介绍" class="headerlink" title="一、树状数组介绍"></a>一、树状数组介绍</h1><p>树状数组是一种用数组模拟的树形结构，修改和查询的复杂度都是<strong>O(logN)</strong>,常用于解决区间更新以及求和问题.<br><img src="https://img-blog.csdnimg.cn/6c7285b44ce545269b1926560b6d1610.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASFozNTU3Mg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上图中:<br>C[1] &#x3D; A[1];<br>C[2] &#x3D; A[1] + A[2];<br>C[3] &#x3D; A[3];<br>C[4] &#x3D; A[1] + A[2] + A[3] + A[4];<br>C[5] &#x3D; A[5];<br>C[6] &#x3D; A[5] + A[6];<br>C[7] &#x3D; A[7];<br>C[8] &#x3D; A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];<br>由此可得这颗树的规律:<br>C[i]&#x3D;A[i-$2^k$+1]+A[i-$2^k$+2]+…+A[i],其中k为i的二进制中从最低位到高位连续零的长度,$2^k$也叫lowbit,可以利用位运算计算,如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><p>树状数组的<strong>单点修改</strong>,<strong>单点查询</strong>和<strong>区间查询</strong>的完整代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bug(a) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bugg(a,b) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> buggg(a,b,c) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">double</span>&gt; P;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> A[N],c[N];<span class="hljs-comment">//对应原数组和树状数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> k)</span></span>&#123; <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        c[i]+=k;<br>        i+=<span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;  <span class="hljs-comment">//求前i项的和</span><br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>        res+=c[i];<br>        i-=<span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;A[i];<br>        <span class="hljs-built_in">updata</span>(i,A[i]);<span class="hljs-comment">//第i个位置加上A[i]；</span><br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">getsum</span>(<span class="hljs-number">3</span>)&lt;&lt;endl;<span class="hljs-comment">//求前三项的和</span><br>    <span class="hljs-built_in">updata</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//把第二个元素加上2</span><br>    cout&lt;&lt;<span class="hljs-built_in">getsum</span>(<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">getsum</span>(<span class="hljs-number">4</span>)-<span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>)&lt;&lt;endl;<span class="hljs-comment">//求区间2~4之间的和</span><br>    cout&lt;&lt;<span class="hljs-built_in">getsum</span>(<span class="hljs-number">2</span>)-<span class="hljs-built_in">getsum</span>(<span class="hljs-number">1</span>)&lt;&lt;endl;<span class="hljs-comment">//求第二个元素的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>区间修改,单点查询</strong>则需要借助差分数组,完整代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bug(a) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bugg(a,b) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> buggg(a,b,c) cout&lt;&lt;<span class="hljs-string">&quot;* &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">double</span>&gt; P;<br><br><span class="hljs-type">int</span> n,m;<br>ll A[N],c[N];<span class="hljs-comment">//对应原数组和树状数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-type">int</span> i,ll k)</span></span>&#123; <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        c[i]+=k;<br>        i+=<span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;  <span class="hljs-comment">//求d数组前i项的和，也就是A[i]的值</span><br>    ll res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>        res+=c[i];<br>        i-=<span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;A[i];<br>        <span class="hljs-built_in">updata</span>(i,A[i]-A[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//第i个位置加上d[i]；</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">char</span> opt;<br>        cin&gt;&gt;opt;<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            cout&lt;&lt;<span class="hljs-built_in">getsum</span>(x)&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> l,r,d;<br>            cin&gt;&gt;l&gt;&gt;r&gt;&gt;d;<span class="hljs-comment">//把区间l~r之间每个元素都加上d</span><br>            <span class="hljs-built_in">updata</span>(l,d);<br>            <span class="hljs-built_in">updata</span>(r+<span class="hljs-number">1</span>,-d);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>区间修改，区间查询</strong>,原理如下:<br>设d[i]为原数组的差分数组,则可推导出原数组前n项和满足下面公式:<br>$$\sum_{i&#x3D;1}^{n}a[i]&#x3D;\sum_{i&#x3D;1}^{n}d[i]-\sum_{i&#x3D;1}^{n}(i-1)*d[i]$$</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br>ll n,a[N],sum1[N],sum2[N];<br><span class="hljs-comment">//sum1[i]:d[i],sum2[i]:(i-1)*d[i]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;-x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-type">int</span> i,ll x)</span></span>&#123;<br>    <span class="hljs-comment">//单点修改</span><br>    ll p1=i;<br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        sum1[i]+=x;<br>        sum2[i]+=x*(p1<span class="hljs-number">-1</span>);<br>        i+=<span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_up</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll x)</span></span>&#123;<br>    <span class="hljs-comment">//使区间l到r中每一个数都加上x</span><br>    <span class="hljs-built_in">updata</span>(l,x);<br>    <span class="hljs-built_in">updata</span>(r+<span class="hljs-number">1</span>,-x);<br>&#125;<br><br><br><span class="hljs-function">ll <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-comment">//求前i项和</span><br>    ll res=<span class="hljs-number">0</span>,p=i;<br>    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>        res+=p*sum1[i]-sum2[i];<br>        i-=<span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">//区间求和</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">getsum</span>(r)-<span class="hljs-built_in">getsum</span>(l<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    ll x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        <span class="hljs-built_in">updata</span>(i,a[i]-a[i<span class="hljs-number">-1</span>]);<br>    &#125;<br><br>    cout&lt;&lt;<span class="hljs-built_in">getsum</span>(<span class="hljs-number">2</span>)&lt;&lt;endl;<br>    <span class="hljs-built_in">range_up</span>(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">getsum</span>(<span class="hljs-number">2</span>)&lt;&lt;endl;<br>    <span class="hljs-built_in">range_up</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">range_sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树基本操作</title>
    <link href="/2022/07/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/07/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//二叉树的创建和基本操作</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK       1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR    0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE    0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW  -1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> TElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BitNode</span>&#123;<br>      TElemType data;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BitNode</span> *lchild,*rchild;<br>&#125;BitNode,*BitTree;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateBitTree</span><span class="hljs-params">(BitTree &amp;T)</span></span>&#123;<br><span class="hljs-comment">//创建一颗二叉树T，按先序遍历的方式创建</span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;ch);<br><span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(!(T=(BitNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BitNode))))  <span class="hljs-keyword">return</span> OVERFLOW;<br>T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBitTree</span>(T-&gt;lchild);<br><span class="hljs-built_in">CreateBitTree</span>(T-&gt;rchild);<br>&#125;<span class="hljs-comment">//if</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<span class="hljs-comment">//CreateBitTree</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BitTree T)</span></span>&#123;<br><span class="hljs-comment">//先序遍历二叉树T</span><br><span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,T-&gt;data);<br><span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);<br>    <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild);<br>&#125;<span class="hljs-comment">//PreOrderTraverse</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BitTree T)</span></span>&#123;<br><span class="hljs-comment">//中序遍历二叉树T</span><br><span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,T-&gt;data);<br>    <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild);<br>&#125;<span class="hljs-comment">//InOrderTraverse</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BitTree T)</span></span>&#123;<br><span class="hljs-comment">//后序遍历二叉树T</span><br><span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild);<br>    <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,T-&gt;data);<br>&#125;<span class="hljs-comment">//InOrderTraverse</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountNode</span><span class="hljs-params">(BitTree T)</span></span>&#123;<br><span class="hljs-comment">//求二叉树T的结点总数</span><br><span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">CountNode</span>(T-&gt;lchild)+<span class="hljs-built_in">CountNode</span>(T-&gt;rchild)+<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">//CountNode</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyMax</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a&gt;=b) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">return</span> b;<br>&#125;<span class="hljs-comment">//MyMax</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetHigh</span><span class="hljs-params">(BitTree T)</span></span>&#123;<br><span class="hljs-comment">//求二叉树T的高度</span><br><span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">MyMax</span>(<span class="hljs-built_in">GetHigh</span>(T-&gt;lchild),<span class="hljs-built_in">GetHigh</span>(T-&gt;rchild))+<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">//GetHigh</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountLeafNode</span><span class="hljs-params">(BitTree T)</span></span>&#123;<br><span class="hljs-comment">//求二叉树T的叶子结点总数</span><br><span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(!T-&gt;lchild&amp;&amp;!T-&gt;rchild) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">CountLeafNode</span>(T-&gt;lchild)+<span class="hljs-built_in">CountLeafNode</span>(T-&gt;rchild);<br>&#125;<span class="hljs-comment">//CountNode</span><br><br><span class="hljs-built_in">main</span>()<br>&#123;<br>   BitTree T;<br>   <span class="hljs-built_in">CreateBitTree</span>(T);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n先序遍历:&quot;</span>);<br>   <span class="hljs-built_in">PreOrderTraverse</span>(T);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n中序遍历:&quot;</span>);<br>   <span class="hljs-built_in">InOrderTraverse</span>(T);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n后序遍历:&quot;</span>);<br>   <span class="hljs-built_in">PostOrderTraverse</span>(T);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n二叉树的结点数为:%d&quot;</span>,<span class="hljs-built_in">CountNode</span>(T));<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n二叉树的高度为:%d&quot;</span>,<span class="hljs-built_in">GetHigh</span>(T));<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n二叉树的叶子结点数为:%d&quot;</span>,<span class="hljs-built_in">CountLeafNode</span>(T));<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小互质数(欧拉筛)</title>
    <link href="/2022/07/15/%E6%9C%80%E5%B0%8F%E4%BA%92%E8%B4%A8%E6%95%B0/"/>
    <url>/2022/07/15/%E6%9C%80%E5%B0%8F%E4%BA%92%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们定义两个数的互质数当且仅当gcd(a, b) &#x3D; 1。<br>现在L手里有n个数，分别为a1，a2，a3 ……an-1，an  。<br>问，没有在这n个数中出现过并且与这n个数都互质的最小的数是多少。<br>LL觉得这个问题太简单了，于是她把这个问题交给你来解决<br><strong>输入</strong><br>第一行一个数n (1 ≤ n, ai ≤ 10^5)<br>接下来n行，每行一个数，分别代表a1，a2，a3 ……an-1，an  。<br><strong>输出</strong><br>输出一行代表答案<br><strong>样例输入</strong><br>5<br>1<br>2<br>3<br>4<br>5<br><strong>样例输出</strong><br>7</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>   这道题如果用暴力破解肯定会TLE，所以我是先用欧拉筛法标记好10^6以内的素数。然后再用sort函数给输入的数据排好序，从1开始按顺序一一往后查找，只要一出现数组中没有的数，就判断是否是质数（利用前面欧拉筛法标记好的的素数数组），如果是质数，就判断其是不是数组中出现过的数的约数，如果不是那么这个数就是答案，如果是，就继续往后找。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> prim[N],a[N],i,j,k,n,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> isp[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//欧拉筛法求2~N之间的素数</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=N;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!isp[i]) prim[++cnt]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i*prim[j]&gt;N) <span class="hljs-keyword">break</span>;<br>            isp[i*prim[j]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%prim[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]!=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//如果数组中最小的数不是1，则这n个数的最小互质数肯定为1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>,k=<span class="hljs-number">2</span>;;i++,k++)&#123;<br>        <span class="hljs-type">bool</span> f=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a[i+<span class="hljs-number">1</span>]!=k+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果a[i+1]!=k+1,则k+1是这个有序数组没有出现过的数</span><br>            <span class="hljs-keyword">if</span>(!isp[k+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//判断是否为素数</span><br>                <span class="hljs-keyword">if</span>(k+<span class="hljs-number">1</span>&gt;a[n])&#123;<span class="hljs-comment">//如果k+1大于数组里最大的数，那么它肯定不可能是数组里任何一个数的约数</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,k+<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">//判断数组里有没有数能被k+1整除</span><br>                    <span class="hljs-keyword">if</span>(a[j]%(k+<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j&gt;n)&#123;<span class="hljs-comment">//数组内没有数能被k+1整除，输出k+1</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,k+<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            k++;<span class="hljs-comment">//若不符合最小互质数条件，则继续往后查找</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
